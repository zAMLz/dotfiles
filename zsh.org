#+TITLE: Zsh
#+AUTHOR: Amlesh Sivanantham (zamlz)
#+ROAM_ALIAS:
#+ROAM_TAGS: CONFIG SOFTWARE
#+ROAM_KEY: https://www.zsh.org/
#+CREATED: [2021-03-29 Mon 18:51]
#+LAST_MODIFIED: [2021-04-30 Fri 20:30:57]

Z Shell (ZSH) is a powerful shell that has more features that something like bash. It's also very configurable.

* Configuration
** Environment
:PROPERTIES:
:header-args:shell: :tangle ~/.zshenv :comments both
:END:

Source system profile

#+begin_src shell
source /etc/profile
#+end_src

Need to source this file which contains locations for all my repos

#+begin_src shell
source $HOME/org/config/lib/repos
#+end_src

Update path to use my custom scripts and other locally installed scripts.

#+begin_src shell
# Update the path variable
export PATH="$HOME/org/config/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/.config/bin:$PATH"

# Update any system specific path settings
source $HOME/sys/path.sh 2> /dev/null
#+end_src

Collection system information

#+begin_src shell
# Get system info
export WSL=$(uname -r | grep "microsoft")
export DISTRO=$(grep --color=none ^ID= /etc/os-release \
    | sed -e 's/^ID=//g' \
    | tr -d '"')
#+end_src

Configure =less= arguments if we are in a windows linux subsystem. It doesn't support some of the standard arguments you would see in a normal =less=.

#+begin_src shell
# Override default windows less arguments
if [ -z "$WSL" ]; then
    export LESS='-R --mouse --wheel-lines=3 --no-init --quit-if-one-screen'
else
    export LESS='-R --no-init --quit-if-one-screen'
fi
#+end_src

Why am I settings my python venv directory here? This could be improved...

#+begin_src shell
# Set the python venv dir
export PYTHON_VENVS_DIR="$HOME/.local/share/python-venvs"
if [ -d "$PYTHON_VENVS_DIR" ]; then
    mkdir -p "$PYTHON_VENVS_DIR"
fi

# Specify location of ledger file
export LEDGER_FILE="$LEDGER_DIR/main.journal"
#+end_src

When using zsh inside [[file:emacs.org][GNU/Emacs]], we also need to update the editor. The default system editor will be [[file:neovim.org][vim]] as its a good fallback, but we definetly do not want it opening inside [[file:emacs.org][GNU/Emacs]].

#+begin_src shell
if [ -n "$INSIDE_EMACS" ]; then
    export VISUAL="emacsclient --socket-name=xorg-emacs-daemon"
    export EDITOR="$VISUAL"
    alias vi="$EDITOR" # lmao
fi
#+end_src

Configure Zsh command history

#+begin_src shell
HISTFILE=$HOME/.zhistory
HISTSIZE=10000
SAVEHIST=5000
#+end_src

This is sort of a weird hack. Basically, we're setting the pinentry program here before we even get to the =~/.zshrc= file. The reason is that we want pinentry to default to /GUI/ based applications instead of the /tty/. But if we enter an interactive shell environment (where =~/.zshrc= would be invoked), then we set it back to /tty/.

#+begin_src shell
#export PINENTRY_USER_DATA='rofi'
#+end_src

** Interactive Session
:PROPERTIES:
:header-args:shell: :tangle ~/.zshrc :comments both
:END:
*** Zsh Configuration

Configure how zsh remembers history.

#+begin_src shell
setopt EXTENDED_HISTORY
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
#+end_src

Other useful defaults like auto-cd and turning off terminal beeps!

#+begin_src shell
setopt AUTO_CD
unsetopt BEEP # turn of audible beeps
#+end_src

Setup Vim Bindings in Zsh.

#+begin_src shell
bindkey -v
#+end_src

*** Load Autocompletion Engine

The directory we store the completion file will already exist due to the tangling of other zsh files.

#+begin_src shell
autoload -Uz compinit && compinit -d "$HOME/.config/zsh.d/compdump"
autoload -U bashcompinit && bashcompinit
#+end_src

*** Source Aliases and Functions

#+begin_src shell
source $HOME/.config/zsh.d/aliases.zsh
source $HOME/.config/zsh.d/functions.zsh
#+end_src

*** Configure SSH & GnuPG Variables

I don't know what to make of this. I thought I could have this code block in the =~/.zshenv= file but I was unable to do so as it causing many issues. Seems like it needs to be set during an interactive session. Very strange indeed. Essentially this configured what pinentry program should be used for [[file:gnupg.org][GnuPG]] and [[file:ssh.org][OpenSSH]]. Furthermore, it also tells [[file:ssh.org][OpenSSH]] that it should look into [[file:gnupg.org][GnuPG]] to get the ssh authentication key.

#+begin_src shell
export GPG_TTY=$(tty)
export PINENTRY_USER_DATA='tty'
export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket);
#+end_src

*** Setup $PS1

There are basically two ways to set prompts. My old prompt was dynamic and required a function to run everytime it generated so we used the precmd cood to generate it. However it introduces some problems with =sh= if you want to run it from =zsh=. Luckily, if you wish to run =sh= from =zsh= for whatever reason, one can simply override the hook before the command is run.

I however, am currently not using this setup, but I should configure it such that if I am in a pure terminal environment that I do in fact use my more /verbose/ prompt. In my gui environment however, that level of information is overkill.

#+begin_src shell
### NOTE: Look at the function definition for prompt_generate()
# precmd() {
#     export PROMPT=$(prompt_generate)
# }

export PS1="%F{blue}%~%f %B%(?.%F{green}.%F{red})Î»%f%b "
#+end_src

*** Override LS Colors

The =ls= command is sometimes not colored properly (and I may have some custom colors that it doesn't like using for certain files by default) so lets override that here. Maybe I should have this in the =~/.zshenv= file?

#+begin_src shell
eval $(dircolors -b $HOME/org/config/lib/shell/lscolors)
#+end_src

*** Enter a Python Virtual Environment

If certain =$VIRTUAL_ENV= exist during session startup, then immediately jump into that python virtual environment.

#+begin_src shell
if [ -n "$VIRTUAL_ENV" ]; then
    source ${VIRTUAL_ENV}/bin/activate
fi
#+end_src

*** Emacs Vterm Shell-side Integration

Woah what is a function doing here!?

Well, Vterm (emacs) requires some shell-side configuration in order to make use of its full functionality. It's quite powerful when as you can jump between prompts and other things. Basically although its a function, I'm keeping it here so that all shell-side code is in one place.

#+begin_src shell
vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}
#+end_src

This is used to pass information about =user=, =hostname=, and =pwd= back to vterm.

#+begin_src shell
vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src

Adding another zsh hook to capture changes in directory I believe. This ultimately is used to set the buffer name for vterm in emacs buffer list.

#+begin_src shell
autoload -U add-zsh-hook
add-zsh-hook -Uz chpwd (){ print -Pn "\e]2;%m:%2~\a" }
#+end_src

** Functions
:PROPERTIES:
:header-args:shell: :tangle ~/.config/zsh.d/functions.zsh :mkdirp yes :comments both
:END:
*** Groot

I wrote a simple script to get me pretty details of a [[file:git.org][Git]] repo.

#+begin_src shell
function groot() {
    GITROOT=$(git rev-parse --show-toplevel 2> /dev/null);
    ROOTEXIST=$?

    if [ $ROOTEXIST -eq 0 ]; then

        cd $GITROOT;
        NAME=$(basename -s .git `git config --get remote.origin.url` 2> /dev/null)

        if [ -z "$NAME" ]; then
            NAME="[ ]"
        fi

        BRANCH=$(git branch --list --no-color | cut -d " " -f 2 | tr -d '\n');
        figlet -t -f slant $@ "${NAME} @.${BRANCH}" | lolcat

        git status
    fi
}
#+end_src

*** One of my many prompts

I really like this prompt. I should probably set this up such that it's only used when I'm using the =tty=. Here is what is normally looks like:

#+begin_src
.-|ssh|-(amlesh@xanadu)-[debian::~/src/website]-<website.master>
`-->
#+end_src

#+begin_src shell
function prompt_generate() {
    echo -ne "%B%F{cyan}.-"

    # Check if we are in an SSH connection
    if [ -n "$SSH_TTY" ]; then
        echo -ne "%F{black}|%b%F{blue}ssh%F{black}%B|%F{cyan}-"
    fi

    # user @ hostname
    echo -ne "%F{black}(%b%F{cyan}%n%F{white}@%F{magenta}%M%F{black}%B)"

    # distro :: current working directory
    echo -ne "%F{cyan}-%F{black}[%b%F{cyan}${DISTRO}"
    echo -ne "%F{white}::%F{blue}%~%B%F{black}]"

    if [ -d "`git rev-parse --show-toplevel 2> /dev/null`/.git" ]; then

        GIT_NAME=$(basename -s .git `git config --get remote.origin.url` \
            2> /dev/null)
        GIT_NAME=$(echo $GIT_NAME | sed -e 's|^.*:||g')

        if [ -z "$GIT_NAME" ]; then
            GIT_NAME="[?]"
        fi

        GIT_BRANCH=$(git branch --list --no-color | grep --color=auto '\*' \
            | sed -e 's/^\* //g' | head -n1 | tr -d '\n')

        # (yes/no add ; no commited)
        #YA=$(git status --porcelain 2>/dev/null| egrep "^M" | wc -l)
        #NA=$(git status --porcelain 2>/dev/null| egrep "^ M" | wc -l)
        NC=$(git status --porcelain 2>/dev/null| egrep "^(M| M | D)" | wc -l)

        # Use this info to construct our real status
        if [ $NC -eq 0 ]; then
            C='green'
        else
            C='red'
        fi
        echo -ne "%F{cyan}-%F{black}<%b%F{$C}$GIT_NAME.$GIT_BRANCH%B%F{black}>"

    fi
    if [ -n "${ENV_NAME}${PIPENV_ACTIVE}${VIRTUAL_ENV}" ]; then

        echo -ne "%F{cyan}-%F{black}{%b%F{yellow}"
        MOD=""

        if [ -n "$VIRTUAL_ENV" ]; then
            # Support both the old way of using venvs and new way
            echo -ne "venv:$(basename $VIRTUAL_ENV /.venv)"
            MOD="/"
        fi

        if [ -n "$PIPENV_ACTIVE" ]; then
            echo -ne "${MOD}pipenv"
            MOD="/"
        fi

        if [ -n "$ENV_NAME" ]; then
            echo -ne "$MOD$ENV_NAME"
        fi

        echo -ne "%B%F{black}}"
    fi
    echo -ne "\n"
    echo -ne "%F{cyan}\`--%B%F{white}> %{\e[0m%}"
}
#+end_src

*** Python Venv Wrapper

There may be a better solution to this, but I just like using the built in =venv= that is part of =python3=. But its a pain to write out every command so this does a lot of things.

#+begin_src shell
function venv() {
    # A simple wrapper for virtualenv
    PYTHON_VENVS_DIR=${PYTHON_VENVS_DIR:-$HOME/.venvs}
    if [[ ! -z "$@" ]]; then
        vname=$1;
        shift;
        if [[ -z "$@" ]]; then
            if [[ ! -d "$PYTHON_VENVS_DIR/$vname" ]]; then
                echo "Create a new virtual environment named '$vname' ?";
                echo 'Press any key to continue or Ctrl+C to exit...\n'
                # note this is zsh read
                read -k1 -rs
                echo "Creating new venv: $vname";
                python -m venv $PYTHON_VENVS_DIR/$vname
            fi
            echo "Starting venv: $vname"
            source $PYTHON_VENVS_DIR/${vname}/bin/activate
            save_window_info
        else
            python -m venv $PYTHON_VENVS_DIR/$vname $@
            save_window_info
        fi
    else
        echo "Python Virtual Environments (venvs)"
        tree -L 1 -d --noreport $PYTHON_VENVS_DIR/ | tail -n +2
    fi
}
#+end_src

*** X Window Terminal Info

The following code helps save [[file:xorg.org][X11]] window information for every terminal. This can be used later to start new terminal sessions in those directories (Meant to be used with [[file:urxvt.org][URxvt]]). In a nuteshell, the built-in =cd= is overridden to now save this window info.

#+begin_src shell
function window_info() {
    echo "WINDOW_PWD='$(pwd)'";
    echo "VIRTUAL_ENV='${VIRTUAL_ENV}'";
}
#+end_src

#+begin_src shell
function save_window_info() {
    window_info > /tmp/.wid_${WINDOWID}
}
#+end_src

Overrides default =cd= and also saves the terminal info at initial startup

#+begin_src shell
if [ -n "$DISPLAY" ]; then
    # Build our custom cd
    function cd () {
        builtin cd $@
        save_window_info
    }
    # Every terminal should generate its id file on spawn
    if [ -z "$WINDOWID" ]; then
        # echo "Terminal doesn't have a Window ID!!!"
    else
        save_window_info
    fi
fi
#+end_src

*** Universal Extract Script

#+begin_src shell
function ext() {
    # Make sure some argument is given
    if [ ! -f "$1" ] ; then
        echo "'$1' does not exist."
        return 1
    fi
    # based on filetype, extract the file
    case "$1" in
        ,*.tar.bz2)   tar xvjf "$1"   ;;
        ,*.tar.xz)    tar xvJf "$1"   ;;
        ,*.tar.gz)    tar xvzf "$1"   ;;
        ,*.bz2)       bunzip2 "$1"    ;;
        ,*.rar)       rar x "$1"      ;;
        ,*.gz)        gunzip "$1"     ;;
        ,*.tar)       tar xvf "$1"    ;;
        ,*.tbz2)      tar xvjf "$1"   ;;
        ,*.tgz)       tar xvzf "$1"   ;;
        ,*.zip)       unzip "$1"      ;;
        ,*.Z)         uncompress "$1" ;;
        ,*.xz)        xz -d "$1"      ;;
        ,*.7z)        7z x "$1"       ;;
        ,*.a)         ar x "$1"       ;;
        ,*)           echo "Unable to extract '$1'." ;;
    esac

}
#+end_src

** Aliases
:PROPERTIES:
:header-args:shell: :tangle ~/.config/zsh.d/aliases.zsh :mkdirp yes :comments both
:END:

Shortcuts for =ls=

#+begin_src shell
alias ls="LC_COLLATE=C ls -F --color=always"
alias ll="ls -oh"
alias la="ls -lah"
#+end_src

Shell aliases to make using [[file:git.org][Git]] easier.

#+begin_src shell
alias gs="git status"
alias ga="git add"
alias gc="git commit"
alias gd="git diff"
alias gds="git diff --staged"
alias gl="git log --graph --stat -p"
alias gp="git push"
alias gf="git fetch"
alias gm="git merge"
alias gb="git branch -av"
#+end_src

These aliases are weird. This was when the term I was using was causing issues with =clear= and other utilities like =eselect=. The problem however was that I couldn't just set the =TERM= to /xterm/ globally as other utilities would also break.

#+begin_src shell
alias clear="TERM='xterm' clear"
alias eselect="TERM='xterm' eselect"
#+end_src

Make various commands pretty by default

#+begin_src shell
alias grep="grep --color=always"
alias tree="tree -C"
#+end_src

Misc things

#+begin_src shell
alias fping="ping -c 3 www.google.com"
alias weather="curl wttr.in"
#+end_src

Ricing info commands

#+begin_src shell
alias info="clear;echo;neofetch;colors;"
alias infos="info;scrot --delay 3 --count --quality 100 ~/tmp/myscrot.png"
#+end_src

Sudo improvements...

#+begin_src shell
alias please="sudo"
if [ $UID -ne 0 ]; then
    alias fuck='eval "sudo $(fc -ln -1)"'
fi
#+end_src

Make certain commands safer to use by default

#+begin_src shell
alias rm="rm -I --preserve-root"
alias mv="mv -i"
alias cp="cp -i"
#+end_src
