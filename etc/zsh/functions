#!/bin/zsh

# Generate our own custom prompt for our shell
ps1_generate() {
    echo -ne "%B%F{cyan}.-"

    # Check if we are in an SSH connection
    if [ -n "$SSH_TTY" ]; then
        echo -ne "%F{black}|%b%F{blue}ssh%F{black}%B|%F{cyan}-"
    fi

    # user @ hostname
    echo -ne "%F{black}(%b%F{cyan}%n%F{white}@%F{magenta}%M%F{black}%B)"

    # distro :: current working directory
    echo -ne "%F{cyan}-%F{black}[%b%F{cyan}${DISTRO}"
    echo -ne "%F{white}::%F{blue}%~%B%F{black}]"

    if [ -d "`git rev-parse --show-toplevel 2> /dev/null`/.git" ]; then

        GIT_NAME=$(basename -s .git `git config --get remote.origin.url` \
            2> /dev/null)

        if [ -z "$GIT_NAME" ]; then
            GIT_NAME="[?]"
        fi

        GIT_BRANCH=$(git branch --list --no-color | cut -d " " -f 2 \
            | tr -d '\n')

        # (yes/no add ; no commited)
        #YA=$(git status --porcelain 2>/dev/null| egrep "^M" | wc -l)
        #NA=$(git status --porcelain 2>/dev/null| egrep "^ M" | wc -l)
        NC=$(git status --porcelain 2>/dev/null| egrep "^(M| M | D)" | wc -l)

        # Use this info to construct our real status
        if [ $NC -eq 0 ]; then
            C='green'
        else
            C='red'
        fi
        echo -ne "%F{cyan}-%F{black}<%b%F{$C}$GIT_NAME.$GIT_BRANCH%B%F{black}>"

    fi
    if [ -n "${ENV_NAME}${PIPENV_ACTIVE}${VIRTUAL_ENV}" ]; then

        echo -ne "%F{cyan}-%F{black}{%b%F{yellow}"
        MOD=""

        if [ -n "$VIRTUAL_ENV" ]; then
            # Support both the old way of using venvs and new way
            echo -ne "venv:$(basename $VIRTUAL_ENV /.venv)"
            MOD="/"
        fi

        if [ -n "$PIPENV_ACTIVE" ]; then
            echo -ne "${MOD}pipenv"
            MOD="/"
        fi

        if [ -n "$ENV_NAME" ]; then
            echo -ne "$MOD$ENV_NAME"
        fi

        echo -ne "%B%F{black}}"
    fi
    echo -ne "\n"
    echo -ne "%F{cyan}\`--%B%F{white}> %{\e[0m%}"
}

# Because of this function above, the sh shell will not work anymore.
# we'll need to override the value of a certain identifier
sh() {
    /bin/sh -c "export precmd=''; exec /bin/sh"
}

# Get current terminal sessions info
window_info() {
    echo "WINDOW_PWD='$(pwd)'";
    echo "VIRTUAL_ENV='${VIRTUAL_ENV}'";
}

save_window_info() {
    window_info > /tmp/.wid_${WINDOWID}
}

# This is a special alias that overrides the
# default behaviour of cd.
# instead it makes cd behave such that it saves the
# directory that we enter.
if [ -n "$DISPLAY" ]; then

    # Build our custom cd
    cd () {
        builtin cd $@
        save_window_info
    }

    # Every terminal should generate its id file on spawn
    if [ -z "$WINDOWID" ]; then
        echo "Terminal doesn't have a Window ID!!!"
    else
        save_window_info
    fi
fi

# Teleport to the root of a git directory
#   needs git and figlet
groot() {
    GITROOT=$(git rev-parse --show-toplevel 2> /dev/null);
    ROOTEXIST=$?
    if [ $ROOTEXIST -eq 0 ]; then

    cd $GITROOT;
    NAME=$(basename -s .git `git config --get remote.origin.url` 2> /dev/null)
    if [ -z "$NAME" ]; then
        NAME="[ ]"
    fi
    BRANCH=$(git branch --list --no-color | cut -d " " -f 2 | tr -d '\n');
    figlet -t -f slant $@ "${NAME}.${BRANCH}"
    git status
    PAGER=cat git diff
    fi
}

# A simple swapper function
sw() {
    T=".$1_tmp"
    mv -vi $1 $T
    mv -vi $2 $1
    mv -vi $T $2
}

# A special function for changing the colorscheme
xcolorscheme() {
    if [ -z "$1" ]; then
        ls $HOME/lib/colorschemes
    else
        rm $HOME/.xcolorscheme
        ln -s $HOME/lib/colorschemes/$1 $HOME/.xcolorscheme
    fi
}

# A simple wrapper for virtualenv
venv() {
    if [[ ! -z "$@" ]]; then
        vname=$1;
        shift;
        if [[ -z "$@" ]]; then
            if [[ ! -d "$HOME/.venvs/$vname" ]]; then
                echo "Create a new virtual environment named '$vname' ?";
                echo 'Press any key to continue or Ctrl+C to exit...\n'
                # note this is zsh read
                read -k1 -rs
                echo "Creating new venv: $vname";
                python -m venv $HOME/.venvs/$vname
            fi
            echo "Starting venv: $vname"
            source $HOME/.venvs/${vname}/bin/activate
            save_window_info
        else
            python -m venv $HOME/.venvs/$vname $@
            save_window_info
        fi
    else
        echo "Python Virtual Environments (venvs)"
        tree -L 1 -d --noreport $HOME/.venvs/ | tail -n +2
    fi
}
