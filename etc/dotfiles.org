#+TITLE: My Personal Dotfiles
#+AUTHOR: Amlesh Sivanantham (zamlz)
#+CREATED: [2021-02-18 Thu 15:09]
#+LAST_MODIFIED: [2021-03-29 Mon 19:16:59]
#+OPTIONS: broken-links:t
#+STARTUP: overview
# ... Present day, present time ...

* Shell Environment
** Isync & Mbsync
:PROPERTIES:
:header-args:conf: :tangle ~/.mbsyncrc
:END:

A tool used to sync and create local IMAP stores.

#+begin_src conf
IMAPAccount gmail
Host imap.gmail.com
User samlesh@gmail.com
PassCmd "pass email/samlesh@gmail.com-app-isync"
SSLType IMAPS
CertificateFile /etc/ssl/certs/ca-certificates.crt

IMAPStore gmail-remote
Account gmail

MaildirStore gmail-local
Subfolders Verbatim
# The trailing "/" is important!
Path ~/.mail/samlesh@gmail.com/
Inbox ~/.mail/samlesh@gmail.com/Inbox

Channel gmail
Master :gmail-remote:
Slave :gmail-local:
Patterns *
Create Both
SyncState *
#+end_src

* Desktop Environment
** Window Manager Utilties Startup Script
:PROPERTIES:
:header-args:shell: :tangle ~/.config/wm_init.sh :mkdirp yes :shebang #!/bin/sh
:END:

This is the main script outside of the actual window mangaer which is triggered by xorg. The purpose of this is to put other programs that need to be started alongside the window manager to create a fully fledged desktop environment. Typically, I've seen these components be in the =~/.xinitrc= file but we don't really want to restart xorg if we want to run some of the initialization code. The other option is to put it in the init file for the window manager, but that would also mean that we have to copy the same code to other init files. Instead its better for it to just have a unified source.

Secondaly, these codeblocks aren't actually tangled anywhere directly. We use =org-babel='s no-web feature which lets us insert code blocks into other code blocks. For example, we insert it into the *herbstluftwm* autostart config.

Like with all other components in my system, setup a logger for debugging purposes.

#+begin_src shell
# We may already have a logger ready to use...
if [ -z "$LOGGER" ]; then
    . $HOME/org/config/lib/shell/logger
    LOGGER=$(get_logger xorg.wminit)
fi
$LOGGER "Initializing window manager common utilities"
#+end_src

Start compton if a config file exists. Looks crisp as hell!

#+begin_src shell
pkill -x compton
if [ -f "$HOME/.config/compton.conf" ]; then
    $LOGGER "Starting Compton"
    compton &
fi
#+end_src

Make sure xrdb loads up the xresouces file

#+begin_src shell
# Reload the xresource data
xrdb -I$HOME $HOME/.Xresources
#+end_src

I had =xst= terminal installed as it was a lightweight alternative to urxvt. If I ever do continue using it, make sure it gets the config reset switch. *NOTE:* this wil fail if the colorscheme isn't properly set!

#+begin_src shell
# Refresh the terminal
pkill -USR1 xst
#+end_src

If I was still using =rxvt-unicode='s daemon, this would be uncommented...

#+begin_src shell
# if [ -z "$(pgrep urxvtd)" ]; then
#     urxvtd -q -o -f
# fi
#+end_src

*Very Important!* Make sure we start the emacs daemon here! But do not start it if it's already running.

#+begin_src shell
if [ -z "$(pgrep -f 'emacs --daemon=xorg-emacs-daemon')"]; then
    emacs --daemon=xorg-emacs-daemon
fi
#+end_src

Set the background for the desktop environment. If =~/.fehbg= doesn't exist, setup the bitmap wallpaper.

#+begin_src shell
# Set the background
if [ -f "$HOME/.fehbg" ]; then
    $HOME/.fehbg
else
    . $HOME/org/config/lib/shell/xrdb_colors
    xsetroot -bitmap ~/org/config/lib/bitmaps/tile.xbm -fg $XCOLOR0 -bg $XBACKGROUND
fi
#+end_src

I use =sxhkd= for keybindings that should exist in all my environments regardless of what window manager I'm using.

#+begin_src shell
# Initialize universal keybindings
SXHKD_SHELL=sh
export SXHKD_TERMINAL=$HOME/org/config/bin/emacsclient-launcher
pkill -x sxhkd
sxhkd &
#+end_src

The single most important thing! Make the *CAPS LOCK* key into the *ESCAPE* key!

#+begin_src shell
setxkbmap -option caps:escape
#+end_src

We need to configure various xorg settings here. This might not be the best place as this definetly feels like something that should belong in the =~/.xinitrc=, however, in case they are set to something other than the defaults, it makes sense to be able to reset them here.

#+begin_src shell
# Use Display Power Management Settings to configure various things.
# + Disable screen blanking (screensaver) (I don't think this works)
xset s off

# + Increases the speed of the keyboard repeat rate
xset r rate 400 50

# Rehash local fonts
xset +fp $HOME/.local/share/fonts
xset fp rehash
#+end_src

Finally start lemonbar once everything else is setup.

#+begin_src shell
# Start lemonbar after all X related stuff is finished
pkill -x lemonbar
$HOME/.config/lemonbar/lemonbar &
#+end_src

** Xorg X11 Window System
*** Xinitrc
:PROPERTIES:
:header-args:shell: :tangle ~/.xinitrc :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/org/config/lib/shell/logger
LOGGER=$(get_logger xinitrc)
#+end_src

Some linux distros have predefined scripts in these locations that need to be sourced in order for proper Xorg operation. Source the global defaults and then the local files if any exist.

#+begin_src shell
# We need to source some things if it exists
$LOGGER "Sourcing xinitrc.d files if they exist"
if [ -d /etc/X11/xinit/xinitrc.d ] ; then
    for f in /etc/X11/xinit/xinitrc.d/*.sh ; do
        [ -x "$f" ] && . "$f"
    done
    unset f
fi

# Repeat for any local scripts if they exist
# Store xrandr monitor setup scripts here!!!
if [ -d $HOME/.config/xinitrc.d ] ; then
    find "$HOME/.config/xinitrc.d" -name "*.sh" | while read -r f; do
        [ -x "$f" ] && . "$f"
    done
    unset f
fi
#+end_src

This part of the script decides which window manager to start. This is ultimately passed as an argument to startx. Take a look at =~/.zlogin= to see how it is triggered.

#+begin_src shell
# Start Window Manager
session=${1:-herbstluftwm}
$LOGGER "Starting session: $session"

EXEC_DBUS="exec dbus-launch --exit-with-session"

case $session in
    herbstluftwm)   $EXEC_DBUS herbstluftwm;;
    exwm)           $EXEC_DBUS emacs -mm --debug-init;;
    *)              exec $1;;
esac
#+end_src

*** Xresources
:PROPERTIES:
:header-args:C: :tangle ~/.Xresources
:END:
**** Source Colorscheme

#+begin_src C
#include ".config/xcolor/scheme"
#+end_src

**** Xft Font Settings

#+begin_src C
Xft.dpi:                    96
Xft.antialias:              true
Xft.rgba:                   rgb
Xft.hinting:                true
Xft.hintstyle:              hintslight
#+end_src

**** Default Font Face

#+begin_src C
!*font: xft:Iosevka Term:size=11
!*font: xft:xos4 Terminus:size=12
#define system_font xft:xos4 Terminus:size=12
#+end_src

**** Rxvt Unicode Terminal
***** General Settings

#+begin_src C
URxvt.depth:                32
URxvt.geometry:             96x33
URxvt.loginShell:           false
URxvt.internalBorder:       10
URxvt.lineSpace:            0
!URxvt.termName:             xterm-256color
#+end_src

***** Transparency

I've disabled all transparency for the time being

#+begin_src C
! fake transparency - true or false (default)
!URxvt*transparent: true

! Real transparency (needs compositor like compton)
! If using make sure to disable the background below.
!URxvt*depth: 32
!URxvt*background: [85]xbackground
#+end_src

***** Misc UI Changes

#+begin_src C
! tint with any color; i.e., blue, red, tomato4, olivedrab2, etc.
!   some nice listings are at:
!     http://www.nisrv.com/drupal/?q=node/11
!     http://www.htmlgoodies.com/tutorials/colors/article.php/3478921
!URxvt*tintColor: S_base03

! shading - 0 to 99 darkens, 101 to 200 lightens.
!   Dont use with tintColor; just use a darker or lighter color instead.
URxvt*shading: 15

URxvt*saveLines: 12000

! scrollbar - true (default) or false
URxvt*scrollBar: false

! scrollbar position - left=false (default) or right=true
URxvt*scrollBar_right: false

! scrollbar style - rxvt (default), plain, next, or xterm
URxvt*scrollstyle: plain
#+end_src

***** Clipboard Keybindings

#+begin_src C
! Remap the copy and paste functionaility
URxvt.keysym.Shift-Control-V: eval:paste_clipboard
URxvt.keysym.Shift-Control-C: eval:selection_to_clipboard
#+end_src

***** Colorscheme and Font

#+begin_src C
URxvt.foreground: xforeground
URxvt.background: xbackground
URxvt.cursorColor: xcursorColor

! This is for fading windows if not active
URxvt.fading: xfade
URxvt.fadeColor: xbackground

URxvt.color0:  xcolor0
URxvt.color1:  xcolor1
URxvt.color2:  xcolor2
URxvt.color3:  xcolor3
URxvt.color4:  xcolor4
URxvt.color5:  xcolor5
URxvt.color6:  xcolor6
URxvt.color7:  xcolor7
URxvt.color8:  xcolor8
URxvt.color9:  xcolor9
URxvt.color10: xcolor10
URxvt.color11: xcolor11
URxvt.color12: xcolor12
URxvt.color13: xcolor13
URxvt.color14: xcolor14
URxvt.color15: xcolor15

URxvt.font: system_font
#+end_src

**** Rofi Dmenu
***** Enabled Modes

#+begin_src C
! "Enabled modi" Set from: Default
rofi.modi:                           window,run,ssh
#+end_src

***** Window Geometry

#+begin_src C
! "Window width" Set from: Default
 rofi.width:                          30

! "Number of lines" Set from: Default
 rofi.lines:                          15

! "Number of columns" Set from: Default
! rofi.columns:                        1
#+end_src

***** Colorscheme and Font

#+begin_src C
! "Font to use" Set from: XResources
rofi.font:                            Iosevka Term 12

! Color Guidlines                       BG -  FG - BG_ALT - HL_BG - HL_FG
! "Color scheme for normal row"
 rofi.color-normal:                     xbackground, xforeground, xbackground, xcolor0, xforeground
! "Color scheme for urgent row"
 rofi.color-urgent:                     xbackground, xforeground, xbackground, xcolor0, xforeground
! "Color scheme for active row"
 rofi.color-active:                     xbackground, xforeground, xbackground, xcolor0, xforeground

! Color Guidlines                       BG          BORDER      SEPEARATOR
! "Color scheme window"
 rofi.color-window:                     xbackground,    xcolor8,    xcolor8
! "Border width" Set from: XResources
rofi.bw:                             4
#+end_src

***** Unused Rofi Settings

#+begin_src C
! "Location on screen" Set from: Default
! rofi.location:                       0
! "Padding" Set from: Default
! rofi.padding:                        5
! "Y-offset relative to location" Set from: Default
! rofi.yoffset:                        0
! "X-offset relative to location" Set from: Default
! rofi.xoffset:                        0
! "Always show number of lines" Set from: Default
! rofi.fixed-num-lines:                true

! "Terminal to use" Set from: XResources
rofi.terminal:                       urxvtc
! "Ssh client to use" Set from: Default
! rofi.ssh-client:                     ssh
! "Ssh command to execute" Set from: Default
! rofi.ssh-command:                    {terminal} -e {ssh-client} {host}
! "Run command to execute" Set from: Default
! rofi.run-command:                    {cmd}
! "Command to get extra run targets" Set from: Default
! rofi.run-list-command:
! "Run command to execute that runs in shell" Set from: Default
! rofi.run-shell-command:              {terminal} -e {cmd}
! "Command executed on accep-entry-custom for window modus" Set from: Default
! rofi.window-command:                 xkill -id {window}

! "Disable history in run/ssh" Set from: Default
! rofi.disable-history:                false
! "Use levenshtein sorting" Set from: Default
! rofi.levenshtein-sort:               false
! "Set case-sensitivity" Set from: Default
! rofi.case-sensitive:                 false

! "Cycle through the results list" Set from: Default
! rofi.cycle:                          true
! "Enable sidebar-mode" Set from: Default
! rofi.sidebar-mode:                   false
! "Row height (in chars)" Set from: Default
! rofi.eh:                             1
! "Enable auto select mode" Set from: Default
! rofi.auto-select:                    false

! "Parse hosts file for ssh mode" Set from: Default
! rofi.parse-hosts:                    false
! "Parse known_hosts file for ssh mode" Set from: Default
! rofi.parse-known-hosts:              true

! "Set the modi to combine in combi mode" Set from: Default
! rofi.combi-modi:                     window,run
! "Set the matching algorithm. (normal, regex, glob, fuzzy)" Set from: Default
! rofi.matching:                       normal
! "Tokenize input string" Set from: Default
! rofi.tokenize:                       true
! "Monitor id to show on" Set from: Default
! rofi.m:                              -5

! "Margin between rows" Set from: Default
! rofi.line-margin:                    2
! "Padding within rows" Set from: Default
! rofi.line-padding:                   1
! "Pre-set filter" Set from: Default
! rofi.filter:
! "Separator style (none, dash, solid)" Set from: Default
! rofi.separator-style:                dash
! "Hide scroll-bar" Set from: Default
! rofi.hide-scrollbar:                 false
! "Fullscreen" Set from: Default
! rofi.fullscreen:                     false
! "Fake transparency" Set from: Default
! rofi.fake-transparency:              false
! "DPI" Set from: Default
! rofi.dpi:                            -1

! "Threads to use for string matching" Set from: Default
! rofi.threads:                        0

! "Scrollbar width" Set from: Default
! rofi.scrollbar-width:                8
! "Scrolling method. (0: Page, 1: Centered)" Set from: Default
! rofi.scroll-method:                  0

! "Background to use for fake transparency. (background or screenshot)" Set from: Default
! rofi.fake-background:                screenshot
! "Window Format. w (desktop name), t (title), n (name), r (role), c (class)" Set from: Default
! rofi.window-format:                  {w}   {c}   {t}
! "Click outside the window to exit" Set from: Default
! rofi.click-to-exit:                  true

! "Indicate how it match by underlining it." Set from: Default
! rofi.show-match:                     true
! "Pidfile location" Set from: Default
! rofi.pid:                            /home/zamlz/.cache/rofi.pid

! "Paste primary selection" Set from: Default
! rofi.kb-primary-paste:               Control+V,Shift+Insert
! "Paste clipboard" Set from: Default
! rofi.kb-secondary-paste:             Control+v,Insert
! "Clear input line" Set from: Default
! rofi.kb-clear-line:                  Control+w
! "Beginning of line" Set from: Default
! rofi.kb-move-front:                  Control+a
! "End of line" Set from: Default
! rofi.kb-move-end:                    Control+e
! "Move back one word" Set from: Default
! rofi.kb-move-word-back:              Alt+b
! "Move forward one word" Set from: Default
! rofi.kb-move-word-forward:           Alt+f
! "Move back one char" Set from: Default
! rofi.kb-move-char-back:              Left,Control+b
! "Move forward one char" Set from: Default
! rofi.kb-move-char-forward:           Right,Control+f
! "Delete previous word" Set from: Default
! rofi.kb-remove-word-back:            Control+Alt+h,Control+BackSpace
! "Delete next word" Set from: Default
! rofi.kb-remove-word-forward:         Control+Alt+d
! "Delete next char" Set from: Default
! rofi.kb-remove-char-forward:         Delete,Control+d
! "Delete previous char" Set from: Default
! rofi.kb-remove-char-back:            BackSpace,Control+h
! "Delete till the end of line" Set from: Default
! rofi.kb-remove-to-eol:               Control+k
! "Delete till the start of line" Set from: Default
! rofi.kb-remove-to-sol:               Control+u
! "Accept entry" Set from: Default
! rofi.kb-accept-entry:                Control+j,Control+m,Return,KP_Enter
! "Use entered text as command (in ssh/run modi)" Set from: Default
! rofi.kb-accept-custom:               Control+Return
! "Use alternate accept command." Set from: Default
! rofi.kb-accept-alt:                  Shift+Return
! "Delete entry from history" Set from: Default
! rofi.kb-delete-entry:                Shift+Delete
! "Switch to the next mode." Set from: Default
! rofi.kb-mode-next:                   Shift+Right,Control+Tab
! "Switch to the previous mode." Set from: Default
! rofi.kb-mode-previous:               Shift+Left,Control+Shift+Tab
! "Go to the previous column" Set from: Default
! rofi.kb-row-left:                    Control+Page_Up
! "Go to the next column" Set from: Default
! rofi.kb-row-right:                   Control+Page_Down
! "Select previous entry" Set from: Default
! rofi.kb-row-up:                      Up,Control+p,Shift+Tab,Shift+ISO_Left_Tab
! "Select next entry" Set from: Default
! rofi.kb-row-down:                    Down,Control+n
! "Go to next row, if one left, accept it, if no left next mode." Set from: Default
! rofi.kb-row-tab:                     Tab
! "Go to the previous page" Set from: Default
! rofi.kb-page-prev:                   Page_Up
! "Go to the next page" Set from: Default
! rofi.kb-page-next:                   Page_Down
! "Go to the first entry" Set from: Default
! rofi.kb-row-first:                   Home,KP_Home
! "Go to the last entry" Set from: Default
! rofi.kb-row-last:                    End,KP_End
! "Set selected item as input text" Set from: Default
! rofi.kb-row-select:                  Control+space
! "Take a screenshot of the rofi window" Set from: Default
! rofi.kb-screenshot:                  Alt+S
! "Toggle case sensitivity" Set from: Default
! rofi.kb-toggle-case-sensitivity:     grave,dead_grave
! "Toggle sort" Set from: Default
! rofi.kb-toggle-sort:                 Alt+grave
! "Quit rofi" Set from: Default
! rofi.kb-cancel:                      Escape,Control+g,Control+bracketleft
! "Custom keybinding 1" Set from: Default
! rofi.kb-custom-1:                    Alt+1
! "Custom keybinding 2" Set from: Default
! rofi.kb-custom-2:                    Alt+2
! "Custom keybinding 3" Set from: Default
! rofi.kb-custom-3:                    Alt+3
! "Custom keybinding 4" Set from: Default
! rofi.kb-custom-4:                    Alt+4
! "Custom Keybinding 5" Set from: Default
! rofi.kb-custom-5:                    Alt+5
! "Custom keybinding 6" Set from: Default
! rofi.kb-custom-6:                    Alt+6
! "Custom Keybinding 7" Set from: Default
! rofi.kb-custom-7:                    Alt+7
! "Custom keybinding 8" Set from: Default
! rofi.kb-custom-8:                    Alt+8
! "Custom keybinding 9" Set from: Default
! rofi.kb-custom-9:                    Alt+9
! "Custom keybinding 10" Set from: Default
! rofi.kb-custom-10:                   Alt+0
! "Custom keybinding 11" Set from: Default
! rofi.kb-custom-11:                   Alt+exclam
! "Custom keybinding 12" Set from: Default
! rofi.kb-custom-12:                   Alt+at
! "Csutom keybinding 13" Set from: Default
! rofi.kb-custom-13:                   Alt+numbersign
! "Custom keybinding 14" Set from: Default
! rofi.kb-custom-14:                   Alt+dollar
! "Custom keybinding 15" Set from: Default
! rofi.kb-custom-15:                   Alt+percent
! "Custom keybinding 16" Set from: Default
! rofi.kb-custom-16:                   Alt+dead_circumflex
! "Custom keybinding 17" Set from: Default
! rofi.kb-custom-17:                   Alt+ampersand
! "Custom keybinding 18" Set from: Default
! rofi.kb-custom-18:                   Alt+asterisk
! "Custom Keybinding 19" Set from: Default
! rofi.kb-custom-19:                   Alt+parenleft

! "The display name of this browser" Set from: Default
! rofi.display-ssh:
! "The display name of this browser" Set from: Default
! rofi.display-run:
! "The display name of this browser" Set from: Default
! rofi.display-drun:
! "The display name of this browser" Set from: Default
! rofi.display-combi:
#+end_src

**** Emacs

Really we set the default colorscheme here so that emacs doesn't blind our eyes we the default black background, but also set some other sane defaults from the default colorscheme so that if emacs does in fact crash, we are in a /dark theme/ environment.

#+begin_src C
Emacs.foreground: xforeground
Emacs.background: xbackground

Emacs.color0:  xcolor0
Emacs.color1:  xcolor1
Emacs.color2:  xcolor2
Emacs.color3:  xcolor3
Emacs.color4:  xcolor4
Emacs.color5:  xcolor5
Emacs.color6:  xcolor6
Emacs.color7:  xcolor7
Emacs.color8:  xcolor8
Emacs.color9:  xcolor9
Emacs.color10: xcolor10
Emacs.color11: xcolor11
Emacs.color12: xcolor12
Emacs.color13: xcolor13
Emacs.color14: xcolor14
Emacs.color15: xcolor15
#+end_src

** Sxhkd - Simple X Hotkey Daemon
:PROPERTIES:
:header-args:shell: :tangle ~/.config/sxhkd/sxhkdrc :mkdirp yes
:END:
*** Terminal Exec Keybindings

This value is specified in =wminit=

#+begin_src shell
# Spawn a normal terminal
super + Return
    $SXHKD_TERMINAL

#+end_src

This actually only works in normal terminals and and not in the emacs vterm. Need to think of another solution to handle that.

#+begin_src shell
# Spawn Terminal matching environment of focused terminal
super + shift + Return
    $HOME/org/config/lib/pwdcfw/$SXHKD_TERMINAL
#+end_src

*** Rofi Dmenu Launcher Keybindings

#+begin_src shell
# Standard $PATH program launcher
super + e
    rofi -show run
#+end_src

#+begin_src shell
# Dmenu for password store
super + p
    $HOME/org/config/lib/rofi/rofi-pass
super + shift + p
    $HOME/org/config/lib/rofi/rofi-pass --qrcode
#+end_src

#+begin_src shell
# Copy a specific bookmark to the clipboard
super + b
    $HOME/org/config/lib/rofi/rofi-book
#+end_src

#+begin_src shell
# Open up a wiki page in read-only mode (originally named notes)
super + n
    $HOME/org/config/lib/rofi/rofi-wiki
super + shift + n
    $HOME/org/config/lib/rofi/rofi-wiki --pdf
#+end_src

#+begin_src shell
# Restore a saved browser session
super + w
    $HOME/org/config/lib/rofi/rofi-browser
#+end_src

#+begin_src shell
# Toggle a display/power profile
super + d
    $HOME/org/config/lib/rofi/rofi-profile
XF86Display
    $HOME/org/config/lib/rofi/rofi-profile
#+end_src

#+begin_src shell
# Control system state (locked, reboot, poweroff, etc.)
#super + Escape
#    $HOME/org/config/lib/rofi/rofi-system LOCK SCREEN
super + ctrl + alt + Escape
    $HOME/org/config/lib/rofi/rofi-system
#+end_src

*** Scrot Keybindings

It's important that these keybindings are prefaces with the =@= token as it implies that the command should be executed on key release as opposed to key press. Scrot and xclip here will not work properly unless they are on key release.

#+begin_src shell
# Interactively select a window or rectangle with the mouse
@Print
    scrot -q 100 -s '/tmp/%F_%T_$wx$h.png' -e 'xclip -selection clipboard -target image/png -i $f'

@shift + Print
    scrot -q 100 '/tmp/%F_%T_$wx$h.png' -e 'xclip -selection clipboard -target image/png -i $f'
#+end_src

*** Media Control Keybindings

#+begin_src shell
XF86MonBrightnessUp
    xbacklight -inc 1 -time 10; \
    $HOME/.config/lemonbar/utils/trigger_fifos bkl

XF86MonBrightnessDown
    xbacklight -dec 1 -time 10; \
    $HOME/.config/lemonbar/utils/trigger_fifos bkl

XF86AudioMute
    pulsemixer --toggle-mute; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioMicMute
    pulsemixer --toggle-mute; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioRaiseVolume
    pulsemixer --change-volume +1; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioLowerVolume
    pulsemixer --change-volume -1; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioPlay
    $HOME/src/spotify-cli/spotify-cli toggle

XF86AudioNext
    $HOME/src/spotify-cli/spotify-cli next

XF86AudioPrev
    $HOME/src/spotify-cli/spotify-cli prev
#+end_src

** Lemonbar Panel
*** Panel Launcher
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/lemonbar :mkdirp yes :shebang #!/bin/sh
:END:

Load config and logger.

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar)
#+end_src

Prevent multiple panels from starting up (really bad).

#+begin_src shell
if [ $(pgrep -cx lemonbar) -gt 1 ]; then
    $LOGGER -s "The panel is already running"
    exit 1
fi
$LOGGER "Starting lemonbar init script"
#+end_src

Using =trap=, we can change the behaviour of our shell script.

#+begin_src shell
trap 'trap - TERM; kill 0' INT TERM QUIT EXIT
#+end_src

Now it's time to make each of the panel FIFOs and start the modules.

#+begin_src shell
# Prepare the FIFOS
$HOME/.config/lemonbar/utils/make_fifos

# Tail command to ensure that fifos never close
TAIL="tail --lines=+1 --follow"

# Add modules to the top fifo
$LOGGER "Setting up top fifo modules"
$HOME/.config/lemonbar/modules/date         > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/network      > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/time         > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/whoami       > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/battery      > $PANEL_TOP_FIFO &
$TAIL $EVENT_BKL_FIFO \
    | $HOME/.config/lemonbar/modules/backlight > $PANEL_TOP_FIFO &

# Add modules to the bot fifo
$LOGGER "Setting up bot fifo modules"
$HOME/.config/lemonbar/modules/cpu          > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/filesystems  > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/memory       > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/spotify      > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/volume_const > $PANEL_BOT_FIFO &
# $HOME/etc/lemonbar/modules/windowinfo   < $EVENT_WIN_FIFO > $PANEL_BOT_FIFO &
$TAIL $EVENT_WSP_FIFO \
    | $HOME/.config/lemonbar/modules/workspaces   > $PANEL_BOT_FIFO &
$TAIL $EVENT_VOL_FIFO \
    | $HOME/.config/lemonbar/modules/volume_event > $PANEL_BOT_FIFO &
#+end_src

Setup the argument string to pass send to lemonbar. Uncomment fonts as needed.

#+begin_src shell
# Define lemonbar opts
# -f dina:size=12
# -f xos4Terminus:style=Bold:size=12
# -f IosevkaTerm:size=12
# -f PowerlineSymbols:style=Medium:size=12
# -f -wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1
OPTS="-g x20
-F ${XBACKGROUND}
-B ${XBACKGROUND}
-f IosevkaTerm:size=12
-f FontAwesome5Free:style=Regular:size=14
-f FontAwesome5Free:style=Solid:size=14
-f FontAwesome5Brands:style=Regular:size=14
-u 3"

$LOGGER "Lemonbar defined with the following opts : $OPTS"
#+end_src

Actually launch our panel loops (while reading from the fifos) and pipe them into lemonbar. We should also pipe the output from lemonbar to a shell process in-case there are modules that want to run specific commands.

#+begin_src shell
# Start the top panel
$LOGGER "Initializing lemonbar using top fifo"
$HOME/.config/lemonbar/utils/loop TOP < $PANEL_TOP_FIFO | lemonbar $OPTS | sh &

# Start the bottom panel
$LOGGER "Initializing lemonbar using bot fifo"
$HOME/.config/lemonbar/utils/loop BOT < $PANEL_BOT_FIFO | lemonbar $OPTS -b | sh &

$LOGGER "Lemonbar finished."
wait
#+end_src

*** Default Configuration
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/config.default :mkdirp yes
:END:

The default configuration is our source for all variables and functions that lemonbar and its modules will need to use. So we also source our utils files and other lib files here.

#+begin_src shell
# Import modules needed but anything that imports this config
. $HOME/org/config/lib/shell/logger
. $HOME/org/config/lib/shell/xrdb_colors
. $HOME/.config/lemonbar/utils/wrappers
. $HOME/.config/lemonbar/utils/multi_monitor_support
. $HOME/.config/lemonbar/utils/where_fifos

# Source local system config in case there are system specific changes
. $HOME/.config/lemonbar/config
#+end_src

Choose the icon wrapper.

#+begin_src shell
# Choose the output wrapper
MSG_WRAPPER=icon_wrapper
#+end_src

Anchors are an important concept with regards to FIFOs. They inform the main loop which module wrote which string.

#+begin_src shell
# Specify the Anchor Character for each module
ANCHOR_BACKLIGHT='L'
ANCHOR_BATTERY='B'
ANCHOR_CPU='C'
ANCHOR_DATE='D'
ANCHOR_FILESYSTEMS='F'
ANCHOR_MEMORY='M'
ANCHOR_NETWORK='N'
ANCHOR_SWAP='S'
ANCHOR_SPOTIFY='J'
ANCHOR_TIME='T'
ANCHOR_WHOAMI='U'
ANCHOR_WININFO='X'
ANCHOR_WORKSPACES='W'
ANCHOR_VOLUME='V'
#+end_src

Setup various refresh timings for various modules

#+begin_src shell
REFRESH_BATTERY=2
REFRESH_CPU=3
REFRESH_DATE=86400
REFRESH_FILESYSTEMS=10
REFRESH_MEMORY=3
REFRESH_NETWORK=2
REFRESH_SWAP=3
REFRESH_TIME=1
REFRESH_VOLUME=2
#+end_src

I played around with fonts in lemonbar, but honestly I'm not really a fan. If I want to enable it at any point, just need to set =LEMONBAR_ENABLE_ICONS= in the local config to be a non-empty string. But this aren't actually used *EVER* in the modules anymore as I'm using powerline icons now. I /should/ probably delete this and remove this segment of code.

#+begin_src shell
# Font Awesome icons for various modules
# https://fontawesome.com/icons?d=gallery&m=free
if [ -n "$LEMONBAR_ENABLE_ICONS" ]; then
    ICON_BACKLIGHT=$(env printf "\uf042 ")
    ICON_BATTERY_AC=$(env printf "\uf1e6 ")
    ICON_BATTERY_EMPTY=$(env printf "\uf244 ")
    ICON_BATTERY_NEAR_EMPTY=$(env printf "\uf243 ")
    ICON_BATTERY_HALF=$(env printf "\uf242 ")
    ICON_BATTERY_NEAR_FULL=$(env printf "\uf241 ")
    ICON_BATTERY_FULL=$(env printf "\uf240 ")
    ICON_BATTYER_CHARGING=$ICON_BATTERY_AC
    ICON_CPU=$(env printf "\uf24d ")
    ICON_DATE=$(env printf "\uf073 ")
    ICON_FILESYSTEMS=$(env printf "\uf0a0 ")
    ICON_MEMORY=$(env printf "\uf538 ")
    ICON_MUSIC=$(env printf "\uf001 ")
    ICON_NETWORK_ETHERNET=$(env printf "\uf796 ")
    ICON_NETWORK_OFFLINE=$(env printf "\uef6ff ")
    ICON_NETWORK_WIFI=$(env printf "\uf1eb ")
    ICON_SWAP=$(env printf "\uf1c0 ")
    ICON_TIME=$(env printf "\uf017 ")
    ICON_WHOAMI=$(env printf "\uf007 ")
    ICON_LINUX=$(env printf "\uf120 ")
    ICON_WORKSPACES=$(env printf "\uf108 ")
    ICON_VOLUME=$(env printf "\uf025 ")
else
    # Some icons are better left as blank so not all are defined
    ICON_BACKLIGHT="bL: "
    ICON_BATTERY_EMPTY="bat: "
    ICON_BATTERY_NEAR_EMPTY=$ICON_BATTERY_EMPTY
    ICON_BATTERY_HALF=$ICON_BATTERY_EMPTY
    ICON_BATTERY_NEAR_FULL=$ICON_BATTERY_EMPTY
    ICON_BATTERY_FULL=$ICON_BATTERY_EMPTY
    ICON_BATTERY_CHARGING="a/c: "
    ICON_CPU="cpu: "
    ICON_MEMORY="mem: "
    ICON_SWAP="swap: "
    ICON_VOLUME="vol: "
fi
#+end_src

There define the powerline icons (to use these, the module strings have to specially confiugred to use them).

#+begin_src shell
# Powerline Icons
PL_R=$(env printf "\ue0b0")
PL_Rb=$(env printf "\ue0b1")
PL_L=$(env printf "\ue0b2")
PL_Lb=$(env printf "\ue0b3")
#+end_src

Setup network interfaces and filesystem paths. These are dummy values and should be overriden with the locally generated config.

#+begin_src shell
# Hardware Specification (override this values in local config)
WIFI_INTERFACE=${WIFI_INTERFACE:-"wlan0"}
ETHERNET_INTERFACE=${ETHERNET_INTERFACE:-"eth0"}
FILESYSTEMS=${FILESYSTEMS:-"/dev/sda4"}
#+end_src

*** Utilities
**** Main Loop
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/loop :mkdirp yes :shebang #!/bin/sh
:END:

Source the main config, setup the loggers and figure out which mode this loop belows to (=TOP= or =BOTTOM=).

#+begin_src shell
. $HOME/.config/lemonbar/config.default
MODE="$1"
LOGGER=$(get_logger "lemonbar.loop.$MODE")

$LOGGER "Configuring the $MODE loop"
#+end_src

This setup below is pretty confusing but it was done because I have two different monitor setups. A triple monitor setup and standalone laptop mode. Depending on the mode we were in, the panel output should be split over three monitors or all should appear on the same one. The variables below simply help in using the same looping function instead of rewriting a different one for each monitor setup. Refer to the lemonbar documentation to understand how monitor specification works.

#+begin_src shell
# Define the monitors
$LOGGER "Checking for multi monitor support"
if [ -f $TRIPLE_MONITOR_TOGGLE ]; then

    MONITOR_1="%{S0}"
    MONITOR_2="%{S1}"
    MONITOR_3="%{S2}"

    M1L="%{l}" M1C="%{c}" M1R="%{r}"
    M2L="%{l}" M2C="%{c}" M2R="%{r}"
    M3L="%{l}" M3C="%{c}" M3R="%{r}"

else

    MONITOR_1="%{S0}%{l}"
    MONITOR_2="%{S0}%{c}"
    MONITOR_3="%{S0}%{r}"

    M1L="" M1C="" M1R=""
    M2L="" M2C="" M2R=""
    M3L="" M3C="" M3R=""

fi
#+end_src

Below is the main loop for lemonbar. It uses the anchors we defined in the config to capture each modules output into module specific variables. We can then print it out to the top and bottom FIFOs.

#+begin_src shell
$LOGGER "Initializing loop to construct lemonbar output"
while read -r line; do
    # echo "Current line: $line" >&2
    case $line in
        $ANCHOR_BACKLIGHT*)     bkl="${line#?}" ;;
        $ANCHOR_BATTERY*)       bat="${line#?}" ;;
        $ANCHOR_CPU*)           cpu="${line#?}" ;;
        $ANCHOR_DATE*)          cal="${line#?}" ;;
        $ANCHOR_FILESYSTEMS*)   fsf="${line#?}" ;;
        $ANCHOR_MEMORY*)        mem="${line#?}" ;;
        $ANCHOR_NETWORK*)       net="${line#?}" ;;
        $ANCHOR_SPOTIFY*)       mus="${line#?}" ;;
        $ANCHOR_TIME*)          clk="${line#?}" ;;
        $ANCHOR_WHOAMI*)        usr="${line#?}" ;;
        $ANCHOR_WININFO*)       win="${line#?}" ;;
        $ANCHOR_WORKSPACES*)    wsp="${line#?}" ;;
        $ANCHOR_VOLUME*)        vol="${line#?}" ;;
    esac

    # Print the contents of our modules based on the mode
    if [ "$MODE" = "TOP" ]; then
        m1="${MONITOR_1}${M1L}${M1C}$usr${M1R}"
        m2="${MONITOR_2}${M2L}${M2C}$cal$clk${M2R}"
        m3="${MONITOR_3}${M3L}$bkl${M3C}$net${M3R}$bat"
        printf "%s\n" "$m1$m2$m3"

    elif [ "$MODE" = "BOT" ]; then
        m1="${MONITOR_1}${M1L}$vol$mus${M1C}${M1R}"
        m2="${MONITOR_2}${M2L}${M2C}$win$wsp${M2R}"
        m3="${MONITOR_3}${M3L}$fsf$mem${M3C}${M3R}$cpu"
        printf "%s\n" "$m1$m2$m3"

    else
        printf "Panel loop given incorrect mode!\n" >&2
    fi
done
#+end_src

**** Make FIFOs
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/make_fifos :mkdirp yes :shebang #!/bin/sh
:END:

We use a seperate script to make the FIFOs so that other processes can start buffering without having to wait for lemonbar to finish starting. *Therefore*, this needs to be called before spawning lemonbar.

Like with all other lemonbar components, setup the logger and get the necessary variables

#+begin_src shell
. $HOME/org/config/lib/shell/logger
. $HOME/.config/lemonbar/utils/where_fifos
LOGGER=$(get_logger lemonbar.make_fifos)
#+end_src

Initialize the actualy panel FIFOs. This is what lemonbar will actually end up reading after all the module output is formatted properly.

#+begin_src shell
$LOGGER "Initializing panel fifo files"
[ -e "$PANEL_TOP_FIFO" ] && rm $PANEL_TOP_FIFO
[ -e "$PANEL_BOT_FIFO" ] && rm $PANEL_BOT_FIFO
mkfifo $PANEL_TOP_FIFO
mkfifo $PANEL_BOT_FIFO
#+end_src

In order to make lemonbar as computationally effecient as possible, we also make use of FIFOs that are used in conjunction with event hooks from external sources. This enables us to update specific modules without the use of the =sleep= command. /Also note to self, there isn't a need to make the =$EVENT_WIN_FIFO= as the module that will use is disabled.../

#+begin_src shell
$LOGGER "Initializing event fifos"
[ -e "$EVENT_BKL_FIFO" ] && rm $EVENT_BKL_FIFO
[ -e "$EVENT_VOL_FIFO" ] && rm $EVENT_VOL_FIFO
[ -e "$EVENT_WSP_FIFO" ] && rm $EVENT_WSP_FIFO
[ -e "$EVENT_WIN_FIFO" ] && rm $EVENT_WIN_FIFO
mkfifo $EVENT_BKL_FIFO
mkfifo $EVENT_VOL_FIFO
mkfifo $EVENT_WSP_FIFO
mkfifo $EVENT_WIN_FIFO
#+end_src

Finally, we need to initialize these FIFOs. I'm pretty confident this has to happen because I was dealing with some issues where the FIFOs would close and lemonbar wasn't able to read their output anymore.

#+begin_src shell
$LOGGER "Starting init writers for event fifos"
echo "backlight fifo init" > $EVENT_BKL_FIFO &
echo "workspace fifo init" > $EVENT_WSP_FIFO &
# echo "window fifo init"    > $EVENT_WIN_FIFO &
echo "volume fifo init"    > $EVENT_VOL_FIFO &
#+end_src

**** Trigger FIFOs
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/trigger_fifos :mkdirp yes :shebang #!/bin/sh
:END:

We use a sepeate script to send signals to the fifos that an event has occured since we don't want oother processes to really know the locations of these fifos in case they change. It also just serves to create a simpler interface lol.

We don't need the config here but we do need to source the locations.

#+begin_src shell
. $HOME/.config/lemonbar/utils/where_fifos
#+end_src

Basically, depending the argument, we send a signal to a specific FIFO. Here are the accepted signals (=bkl=, =wsp=, =win=, =vol=).

#+begin_src shell
TRIGGER_FIFO=$1

if [ $TRIGGER_FIFO = "bkl" ]; then
    echo "." > $EVENT_BKL_FIFO
elif [ $TRIGGER_FIFO = "wsp" ]; then
    echo "." > $EVENT_WSP_FIFO
elif [ $TRIGGER_FIFO = "win" ]; then
    echo "." > $EVENT_WSP_FIFO
elif [ $TRIGGER_FIFO = "vol" ]; then
    echo "." > $EVENT_VOL_FIFO
fi
#+end_src

**** Where FIFOs
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/where_fifos :mkdirp yes
:END:

Not much to be said here. This is just a seperate config file that keeps track of where we make the FIFOs in case I decide to change them.

#+begin_src shell
# Primary FIFOs
PANEL_TOP_FIFO=/tmp/.lemonbar.panel_top.fifo
PANEL_BOT_FIFO=/tmp/.lemonbar.panel_bot.fifo

# Event FIFOs
EVENT_BKL_FIFO=/tmp/.lemonbar.backlight_event.fifo
EVENT_VOL_FIFO=/tmp/.lemonbar.volume_event.fifo
EVENT_WSP_FIFO=/tmp/.lemonbar.workspace_event.fifo
EVENT_WIN_FIFO=/tmp/.lemonbar.wininfo_event.fifo
#+end_src

**** Output Wrappers
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/wrappers :mkdirp yes
:END:

Wrappers are basically used by the modules so that we don't have to rewrite output code code for each module. *Ironically* I ended up doing that anyway since I decide to setup a powerline look for them. In any case, there are still here in case I want to use them in the future. And maybe, it might be possible to setup a more complicated wrapper that supports powerline icons.

The minimal wrapper just displays text in square brackets for each module and its also colored as well.

#+begin_src shell
# Minimal wrapper
legacy_wrapper() {
    icon=$1 && shift && color=$1 && shift && msg=$@
    printf "[$icon %{F$color}$msg%{F-}]"
}
#+end_src

The icon wrapper on the other hand is meant for displaying the module with a font icon (this is configured through the global config file) and the default icons are the SIJI icon pack.

#+begin_src shell
# Use siji fonts or some other unicode fonts
icon_wrapper() {
    icon=$1 && shift && color=$1 && shift && msg=$@
    printf " $icon %%{F$color}$msg%%{F-} "
}
#+end_src

The debug wrapper is primarily used when debugging a module since all the formatting can sometimes make it hard to tell what the panel is really outputting.

#+begin_src shell
# debug wrapper for testing
debug_wrapper() {
    icon=$1 && shift && color=$1 && shift && msg=$@
    echo -ne "[DEBUG $icon $color $msg]"
}
#+end_src

**** Multi-Monitor Support
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/multi_monitor_support :mkdirp yes
:END:

This might be pointless to keep as a seperate script but as (not anymore) was another script that needed the location of where to trigger the monitor toggle (whether I am in a multi monitor environment or not), this was necessary. Keep it setup for backwards compatibility.

#+begin_src shell
# Triple Monitor Toggle File
TRIPLE_MONITOR_TOGGLE=$HOME/.config/lemonbar/enable_triple_monitor
#+end_src

*** Modules
**** Backlight
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/backlight :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.backlight)

$LOGGER "Initializing backlight module"

while read -r backlight_event; do
    msg="$(xbacklight -get | sed -e 's/\.[0-9]*//g')"
    if [ -z "$msg" ]; then
        echo "$ANCHOR_BACKLIGHT%{F$BLACK}${PL_L}%{F-}"
    else
        msg="$msg%"
        msg="%{B$BLACK}%{F$WHITE} ${ICON_BACKLIGHT}$msg %{F-}%{B-}"
        msg="%{F$BLACK}${PL_L}%{F-}$msg"
        msg="$msg%{B$BLACK}%{F$GREEN}${PL_Lb}%{F-}%{B-}"
        echo "$ANCHOR_BACKLIGHT$msg"
    fi
done
#+end_src

**** Battery
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/battery :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.battery)

$LOGGER "Initializing battery module"

# TODO: Dynamically set this based on status
bg_color=$GREEN
fg_color=$XBACKGROUND
oscillator=0
refresh_rate=$REFRESH_BATTERY

while true; do
    batloc="/sys/class/power_supply/"
    batlist=$(ls $batloc | grep "BAT")
    out=""
    icon=""

    if [ -n "${batlist}" ]; then
        for bat in $batlist; do
            cap="$(cat ${batloc}${bat}/capacity)"
            stat="$(cat ${batloc}${bat}/status)"
            batid=$(echo $bat | tr -d 'BAT')

            # Uncomment this if I use a laptop with more than 1 battery again
            #out="${out} ${batid}:${cap}%"
            out="${out}${cap}%"

            if [ $cap -lt 15 ] && [ $stat = "Discharging" ]; then
                refresh_rate="0.2"
                icon=$ICON_BATTERY_EMPTY
                if [ $oscillator -eq 0 ]; then
                    bg_color=$RED
                    fg_color=$XBACKGROUND
                    oscillator=1
                else
                    fg_color=$RED
                    bg_color=$XBACKGROUND
                    oscillator=0
                fi
            else
                bg_color=$GREEN
                fg_color=$XBACKGROUND
                oscillator=0
                refresh_rate=$REFRESH_BATTERY
                icon=$ICON_BATTERY_FULL
            fi

        done
    else
        icon=$ICON_BATTERY_AC
        out="${out}A/C"
    fi

    msg="%{B$bg_color}%{F$fg_color} ${icon}$out %{F-}%{B-}"
    msg="%{F$bg_color}%{B$BLACK}${PL_L}%{B-}%{F-}$msg"

    echo "$ANCHOR_BATTERY$msg"
    sleep $refresh_rate
done
#+end_src

**** CPU
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/cpu :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.cpu)

$LOGGER "Initializing cpu module"

while true; do
    msg=$(cat /proc/loadavg | awk '{print $1}')

    # TODO: Dynamically set this based on cpu load
    color=$MAGENTA

    msg="%{B$color} ${ICON_CPU}$msg %{B-}"
    msg="%{F$color}%{B$BLACK}${PL_L}%{B-}%{F-}$msg"

    echo "$ANCHOR_CPU$msg"
    sleep $REFRESH_CPU
done
#+end_src

**** Date
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/date :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.date)

$LOGGER "Initializing date module"

# Set the refresh time to how many seconds till midnight
REFRESH_DATE=$(($(date -d 23:59:59 +%s) - $(date +%s) + 1))

while true; do
    #msg="%{F$GREEN}$(date +'%A, %d %B %Y')%{F-}"
    msg="%{B$BLACK}%{F$CYAN} ${ICON_DATE}$(date +'%a %Y/%m/%d')"
    msg="%{F$BLACK}${PL_L}%{F-}$msg "
    echo "$ANCHOR_DATE$msg"
    sleep $REFRESH_DATE
    REFRESH_DATE=86400 # Update the seconds to total seconds in a day
done
#+end_src

**** Filesystems
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/filesystems :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.filesystems)

$LOGGER "Initializing filesystems module"

while true; do

    msg=""
    for FS in $FILESYSTEMS; do
        fs_info=$(df | grep $FS)
        if [ -n "$fs_info" ]; then
            fs_path=$(echo $fs_info | awk '{print $6}' | sed -e 's|/home/zamlz|~|g')
            fs_used=$(echo $fs_info | awk '{print $5}')
            msg="$msg $fs_path:$fs_used"
        fi
    done

    msg="%{B$BLACK}%{F$WHITE} ${ICON_FILESYSTEMS}$msg %{F-}%{B-}"
    msg="%{F$BLACK}${PL_L}%{F-}$msg"

    echo "$ANCHOR_FILESYSTEMS$msg"
    sleep $REFRESH_FILESYSTEMS
done
#+end_src

**** Memory
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/memory :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.memory)

$LOGGER "Initializing memory module"

while true; do
    memory=$(free -h | grep 'Mem:')
    memory_total=$(echo $memory | awk {'print $2'} | tr -d ' ')
    memory_used=$(echo $memory | awk {'print $3'} | tr -d ' ')
    mem_msg="$memory_used/$memory_total"

    # TODO: Set this dynamically based on used mem
    mem_color=$MAGENTA

    swap=$(free -h | grep 'Swap:')
    swap_total=$(echo $swap | awk {'print $2'} | tr -d ' ')
    swap_used=$(echo $swap | awk {'print $3'} | tr -d ' ')
    swap_msg="$swap_used/$swap_total"

    # TODO: Set this dynamically based on used mem
    swap_color=$MAGENTA

    msg="%{B$BLACK}%{F$MAGENTA}${PL_Lb}%{F-}"
    msg="$msg%{F$mem_color} ${ICON_MEMORY}$mem_msg %{F-}"
    msg="$msg%{F$MAGENTA}${PL_Lb}%{F-}"
    msg="$msg%{F$swap_color} ${ICON_SWAP}$swap_msg %{F-}%{B-}"

    echo "$ANCHOR_MEMORY$msg"
    sleep $REFRESH_MEMORY
done
#+end_src

**** Network
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/network :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.network)

$LOGGER "Initializing network module"

# State file for identifying if lemonbar displays ip address or not
ip_toggle="/tmp/.ip_toggle"

while true; do

    wifi_status=$(ip -br addr | grep $WIFI_INTERFACE)
    ethernet_status=$(ip -br addr | grep $ETHERNET_INTERFACE)

    interface=""
    primary_msg=""
    icon=""

    # Check if wifi is online
    if [ "$(echo $wifi_status | awk '{print $2}')" = "UP" ]; then

        ssid=$(iw $WIFI_INTERFACE link \
            | grep 'SSID:' \
            | sed -E "s/.*SSID:(.*)/\\1/")

        signal=$(iw $WIFI_INTERFACE link \
            | grep 'signal' \
            | awk '{print $2}')

        interface=$WIFI_INTERFACE
        primary_msg="$ssid ($signal dBm)"
        ip_addr=$(echo $wifi_status | awk '{print $3}')
        icon=$ICON_NETWORK_WIFI

    # Check if ethernet is online
    elif [ "$(echo $ethernet_status | awk '{print $2}')" = "UP" ]; then
        interface=$ETHERNET_INTERFACE
        primary_msg="Ethernet"
        ip_addr=$(echo $ethernet_status | awk '{print $3}')
        icon=$ICON_NETWORK_ETHERNET

    # State we are offline
    else
        interface="localhost"
        primary_msg="OFFLINE"
        ip_addr="127.0.0.1/8"
        icon=$ICON_NETWORK_OFFLINE
    fi

    # If the ip toggle file exists, print the ip address
    if [ -f "$ip_toggle" ]; then
        msg="%{A:rm $ip_toggle:}${icon}$interface: $ip_addr%{A}"
    else
        msg="%{A:touch $ip_toggle:}${icon}$interface: $primary_msg%{A}"
    fi

    msg="%{B$BLACK}%{F$GREEN} $msg %{F-}%{B-}"
    echo "$ANCHOR_NETWORK$msg"
    sleep $REFRESH_NETWORK
done
#+end_src

**** Spotify
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/spotify :mkdirp yes :shebang #!/bin/sh
:END:

This makes use of =spotify-cli=, a simple script I wrote that interfaces with spotify's dbus.

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.spotify)

$LOGGER "Initializing spotify module"

# Colors are actually set in date!!!!
while true; do
    # This repo should be cloned or installed
    metadata=$($HOME/src/spotify-cli/spotify-cli)

    if [ -z "$(echo $metadata | grep 'ERROR')"]; then

        # Notice how the first message doesn't have a foreground color open
        # statement but has a close statement. This is because we are capturing
        # the color change from the [volume] module.
        msg="%{B$BLACK}${PL_R}%{B-}%{F-}"

        # Gather info from the spotify cli script
        title=$(echo $metadata | sed -e 's/title: \(.*\) artist:.*/ \1 /')
        artist=$(echo $metadata | sed -e 's/.*artist: \(.*\) album:.*/\1/')
        paused=$(echo $metadata | sed -e 's/.*status: \(.*\)/\1/')

        artist=" ${ICON_MUSIC}${artist} "
        if [ "$paused" != "Paused" ]; then
            status_color=$WHITE
        else
            status_color=$XBACKGROUND
        fi

        msg="$msg%{B$BLACK}%{F$CYAN}$artist"
        msg="$msg${PL_Rb}%{F-}%{F$status_color}"
        msg="$msg$title%{B-}%{F$BLACK}${PL_R}%{F-}"
    else

        # IMPORTANT: look at comment above
        msg="%{B$XBACKGROUND}${PL_R}%{B-}%{F-}"
    fi

    echo "$ANCHOR_SPOTIFY$msg"
    sleep $REFRESH_TIME
done
#+end_src

**** Time
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/time :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.time)

$LOGGER "Initializing time module"

# Colors are actually set in date!!!!
while true; do
    msg="$(date +'%l:%M:%S %p') %{F-}%{B-}"
    msg="  %{F$CYAN}${ICON_TIME}$msg%{F$BLACK}${PL_R}%{F-}"
    echo "$ANCHOR_TIME$msg"
    sleep $REFRESH_TIME
done
#+end_src

**** Who am I
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/whoami :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.whoami)

$LOGGER "Initializing whoami module"

wmsg="${ICON_WHOAMI}$(whoami)@$(hostname)"

version=$(uname -r | sed -e 's/-.*//g')
distro=$(grep ^ID= /etc/os-release | sed -e 's/^ID=//g' | tr -d '"')
distro=$(echo $distro | sed 's/.*/\u&/')
umsg="${ICON_LINUX}$distro $(uname -o) $version $(uname -m)"

prm_color='#256568'
alt_color=$BLACK

msg="%{B$prm_color} $wmsg %{B-}"
msg="$msg%{F$prm_color}%{B$alt_color}${PL_R}%{F-}"
msg="$msg %{F$prm_color}$umsg%{F-} %{B-}"
msg="$msg%{F$alt_color}${PL_R}%{F-}"

echo "$ANCHOR_WHOAMI$msg"
#+end_src

**** Volume
:PROPERTIES:
:header-args:shell: :mkdirp yes :shebang #!/bin/sh
:END:

The volume module is a bit different from the other modules so far. We need to update it whenever we trigger a volume change (this is done by capturing the volume events via the media keys. Herbstluftwm will then pass a message to the volume event FIFO). However this is not enough as the volume can be changed by the software as well. So ontop of this, we also have a periodic update as well.

/Here is the primary update logic:/

#+NAME: LEMONBAR_VOLUME_UPDATE_OP
#+begin_src shell
# LEMONBAR_VOLUME_UPDATE_OP
if [ $(pulsemixer --get-mute) -eq 0 ]; then
    msg="$(pulsemixer --get-volume | awk '{print $1}')%"
    color=$CYAN
else
    msg="MUTE"
    color=$RED
fi
msg="%{B$color} ${ICON_VOLUME}$msg %{B-}%{F$color}"
echo "$ANCHOR_VOLUME$msg"
#+end_src

/Where is the periodic version of the volume module:/

#+begin_src shell :noweb yes :tangle ~/.config/lemonbar/modules/volume_const
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.volume.const)

$LOGGER "Initializing volume module [constant]"

while true; do
    <<LEMONBAR_VOLUME_UPDATE_OP>>
    sleep $REFRESH_VOLUME
done
#+end_src

/Here is the event triggered version of the volume module:/

#+begin_src shell :noweb yes :tangle ~/.config/lemonbar/modules/volume_event
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.volume.event)

$LOGGER "Initializing volume module [event driven]"

while read -r volume_event; do
    (
        <<LEMONBAR_VOLUME_UPDATE_OP>>
    ) &
done
#+end_src

**** Window Info
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/windowinfo :mkdirp yes :shebang #!/bin/sh
:END:

I don't actually use this module anymore, but its here in case I ever do again.

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.windowinfo)

$LOGGER "Initializing windowinfo module"

while read -r window_event; do
    win_active=$(xdotool getactivewindow)
    win_class=$(xprop -id $win_active \
        | grep WM_CLASS \
        | awk '{print $NF}' \
        | tr -d '"' )

    if [ -z "$win_class" ]; then
        msg="<$(xprop -root _NET_WM_NAME \
            | cut -d " " -f3- \
            | tr -d '"')>"
    else
        msg="$win_class ($win_active)"
    fi
    msg=$($MSG_WRAPPER $ICON_WININFO $BLUE $msg)
    echo "$ANCHOR_WININFO$msg"
    sleep $REFRESH_WININFO
done
#+end_src

**** Workspaces
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/workspaces :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.workspaces)

$LOGGER "Initializing workspaces module [herbstluftwm]"

hclm() {
    herbstclient list_monitors
}

while read -r workspace_event; do
    # For whatever happens here so we can speed up the updates even further
    # commented for now, but uncomment to make it faster
    (

    # convert the current space id to index-1 format
    current_space_id=$(xprop -root _NET_CURRENT_DESKTOP \
        | awk '{print $3}')
    total_spaces=$(xprop -root _NET_NUMBER_OF_DESKTOPS \
        | awk '{print $3}')
    all_space_names=$(xprop -root _NET_DESKTOP_NAMES \
        | cut -d " " -f3- \
        | tr -d ',"')
    active_windows=$(xprop -root _NET_CLIENT_LIST \
        | cut -d " " -f5- \
        | tr -d ',')
    active_spaces=$(for window in $active_windows; do \
        xprop -id $window _NET_WM_DESKTOP \
        | cut -d " " -f3- ; done)
    msg=""

    # Is there to get this info without relying on herbs?
    mon_1=$(hclm | grep '0:' | awk '{print $5}' | tr -d '"')
    mon_2=$(hclm | grep '1:' | awk '{print $5}' | tr -d '"')
    mon_3=$(hclm | grep '2:' | awk '{print $5}' | tr -d '"')

    for space_id in $(seq $total_spaces); do

        # Get the actual name of the workspace
        ws=$(echo $all_space_names | awk -v N=$space_id '{print $N}')
        # Fix the index of the space_id to be zero index
        # (note, awk needs to be in index 1 format)
        space_id=$((space_id - 1))

        # check if the workspace is empty
        if [ "$ws" = "$mon_1" ]; then
            ws="%{F$RED}$ws%{F-}"
        elif [ "$ws" = "$mon_2" ]; then
            ws="%{F$GREEN}$ws%{F-}"
        elif [ "$ws" = "$mon_3" ]; then
            ws="%{F$BLUE}$ws%{F-}"
        elif [ -z "$(echo $active_spaces | grep $space_id)" ]; then
            ws="%{F$XBACKGROUND}$ws%{F-}"
        else
            ws="%{F#585858}$ws%{F-}"
        fi

        # mark output if currently focused
        if [ $space_id -eq $current_space_id ]; then
            msg="$msg %{+u}$ws%{-u}"
        else
            msg="$msg $ws"
        fi
    done;

    l_msg="%{F$BLACK}${PL_L}%{F-}%{B$BLACK}"
    r_msg="%{B-}%{F$BLACK}${PL_R}%{F-}"

    msg="$l_msg %{F$WHITE}${ICON_WORKSPACES}%{F-}$msg  $r_msg"

    echo "$ANCHOR_WORKSPACES$msg"

    ) &
done
#+end_src

** Compton X11 Compositor
:PROPERTIES:
:header-args:conf: :tangle ~/.config/compton.conf :mkdirp yes
:END:
[[http://9m.no/ꪯ鵞][Thank you code_nomad!]] Copied a lot of this person's config...
*** Backend

Backend to use: "xrender" or "glx".
GLX backend is typically much faster but depends on a sane driver.

#+begin_src conf
# Provide the backend to use
backend = "xrender";
#+end_src

*** GLX backend

#+begin_src conf
# ??? Don't remember what this does...
glx-no-stencil = true;

# GLX backend: Copy unmodified regions from front buffer instead of redrawing them all.
# My tests with nvidia-drivers show a 10% decrease in performance when the whole screen is modified,
# but a 20% increase when only 1/4 is.
# My tests on nouveau show terrible slowdown.
# Useful with --glx-swap-method, as well.
glx-copy-from-front = false;

# GLX backend: Avoid rebinding pixmap on window damage.
# Probably could improve performance on rapid window content changes, but is known to break things on some drivers (LLVMpipe).
# Recommended if it works.
# glx-no-rebind-pixmap = true;

# GLX backend: GLX buffer swap method we assume.
# Could be undefined (0), copy (1), exchange (2), 3-6, or buffer-age (-1).
# undefined is the slowest and the safest, and the default value.
# copy is fastest, but may fail on some drivers,
# 2-6 are gradually slower but safer (6 is still faster than 0).
# Usually, double buffer means 2, triple buffer means 3.
# buffer-age means auto-detect using GLX_EXT_buffer_age, supported by some drivers.
# Useless with --glx-use-copysubbuffermesa.
# Partially breaks --resize-damage.
# Defaults to undefined.
glx-swap-method = "undefined";
#+end_src

*** Shadows

#+begin_src conf
# Enabled client-side shadows on windows.
shadow = true;
# Don't draw shadows on DND windows.
no-dnd-shadow = true;
# Avoid drawing shadows on dock/panel windows.
no-dock-shadow = true;
# Zero the part of the shadow's mask behind the window. Fix some weirdness with ARGB windows.
clear-shadow = true;
# The blur radius for shadows. (default 12)
shadow-radius = 5;
# The left offset for shadows. (default -15)
shadow-offset-x = -5;
# The top offset for shadows. (default -15)
shadow-offset-y = -5;
# The translucency for shadows. (default .75)
shadow-opacity = 0.5;

# Set if you want different colour shadows
# shadow-red = 0.0;
# shadow-green = 0.0;
# shadow-blue = 0.0;

# The shadow exclude options are helpful if you have shadows enabled. Due to the way compton draws its shadows, certain applications will have visual glitches
# (most applications are fine, only apps that do weird things with xshapes or argb are affected).
# This list includes all the affected apps I found in my testing. The "! name~=''" part excludes shadows on any "Unknown" windows, this prevents a visual glitch with the XFWM alt tab switcher.
shadow-exclude = [
    "! name~=''",
    "name = 'Notification'",
    "name = 'Plank'",
    "name = 'Docky'",
    "name = 'Kupfer'",
    "name = 'xfce4-notifyd'",
    "name *= 'VLC'",
    "name *= 'compton'",
    "name *= 'Chromium'",
    "name *= 'Chrome'",
    "class_g = 'Conky'",
    "class_g = 'Kupfer'",
    "class_g = 'Synapse'",
    "class_g ?= 'Notify-osd'",
    "class_g ?= 'Cairo-dock'",
    "class_g ?= 'Xfce4-notifyd'",
    "class_g ?= 'Xfce4-power-manager'",
    "_GTK_FRAME_EXTENTS@:c"
];
# Avoid drawing shadow on all shaped windows (see also: --detect-rounded-corners)
shadow-ignore-shaped = false;
#+end_src

*** Opacity

#+begin_src conf
# Define opacity
menu-opacity = 1;
inactive-opacity = 1;
active-opacity = 1;
frame-opacity = 1;
inactive-opacity-override = false;
alpha-step = 0.06;

# Dim inactive windows. (0.0 - 1.0)
# inactive-dim = 0.2;
# Do not let dimness adjust based on window opacity.
# inactive-dim-fixed = true;
# Blur background of transparent windows. Bad performance with X Render backend. GLX backend is preferred.
# blur-background = true;
# Blur background of opaque windows with transparent frames as well.
# blur-background-frame = true;
# Do not let blur radius adjust based on window opacity.
blur-background-fixed = false;
blur-background-exclude = [
    "window_type = 'dock'",
    "window_type = 'desktop'"
];
#+end_src

*** Fading

#+begin_src conf
# Fade windows during opacity changes.
fading = true;
# The time between steps in a fade in milliseconds. (default 10).
fade-delta = 4;
# Opacity change between steps while fading in. (default 0.028).
fade-in-step = 0.03;
# Opacity change between steps while fading out. (default 0.03).
fade-out-step = 0.03;
# Fade windows in/out when opening/closing
# no-fading-openclose = true;

# Specify a list of conditions of windows that should not be faded.
fade-exclude = [ ];
#+end_src

*** Other

#+begin_src conf
# Try to detect WM windows and mark them as active.
mark-wmwin-focused = true;
# Mark all non-WM but override-redirect windows active (e.g. menus).
mark-ovredir-focused = true;
# Use EWMH _NET_WM_ACTIVE_WINDOW to determine which window is focused instead of using FocusIn/Out events.
# Usually more reliable but depends on a EWMH-compliant WM.
use-ewmh-active-win = true;
# Detect rounded corners and treat them as rectangular when --shadow-ignore-shaped is on.
detect-rounded-corners = true;

# Detect _NET_WM_OPACITY on client windows, useful for window managers not passing _NET_WM_OPACITY of client windows to frame windows.
# This prevents opacity being ignored for some apps.
# For example without this enabled my xfce4-notifyd is 100% opacity no matter what.
detect-client-opacity = true;

# Specify refresh rate of the screen.
# If not specified or 0, compton will try detecting this with X RandR extension.
refresh-rate = 0;

# Set VSync method. VSync methods currently available:
# none: No VSync
# drm: VSync with DRM_IOCTL_WAIT_VBLANK. May only work on some drivers.
# opengl: Try to VSync with SGI_video_sync OpenGL extension. Only work on some drivers.
# opengl-oml: Try to VSync with OML_sync_control OpenGL extension. Only work on some drivers.
# opengl-swc: Try to VSync with SGI_swap_control OpenGL extension. Only work on some drivers. Works only with GLX backend. Known to be most effective on many drivers. Does not actually control paint timing, only buffer swap is affected, so it doesn’t have the effect of --sw-opti unlike other methods. Experimental.
# opengl-mswc: Try to VSync with MESA_swap_control OpenGL extension. Basically the same as opengl-swc above, except the extension we use.
# (Note some VSync methods may not be enabled at compile time.)
vsync = "opengl-swc";

# Enable DBE painting mode, intended to use with VSync to (hopefully) eliminate tearing.
# Reported to have no effect, though.
dbe = false;
# Painting on X Composite overlay window. Recommended.
paint-on-overlay = true;

# Limit compton to repaint at most once every 1 / refresh_rate second to boost performance.
# This should not be used with --vsync drm/opengl/opengl-oml as they essentially does --sw-opti's job already,
# unless you wish to specify a lower refresh rate than the actual value.
sw-opti = true;

# Unredirect all windows if a full-screen opaque window is detected, to maximize performance for full-screen windows, like games.
# Known to cause flickering when redirecting/unredirecting windows.
# paint-on-overlay may make the flickering less obvious.
unredir-if-possible = true;

# Specify a list of conditions of windows that should always be considered focused.
focus-exclude = [ ];

# Use WM_TRANSIENT_FOR to group windows, and consider windows in the same group focused at the same time.
detect-transient = true;
# Use WM_CLIENT_LEADER to group windows, and consider windows in the same group focused at the same time.
# WM_TRANSIENT_FOR has higher priority if --detect-transient is enabled, too.
detect-client-leader = true;
#+end_src

*** Window Type Settings

#+begin_src conf
wintypes:
{
    tooltip =
    {
        # fade: Fade the particular type of windows.
        fade = true;
        # shadow: Give those windows shadow
        shadow = false;
        # opacity: Default opacity for the type of windows.
        opacity = 0.85;
        # focus: Whether to always consider windows of this type focused.
        focus = true;
    };
};
#+end_src
