#+TITLE: My Personal Dotfiles
#+AUTHOR: Amlesh Sivanantham (zamlz)
#+CREATED: [2021-02-18 Thu 15:09]
#+LAST_MODIFIED: [2021-03-29 Mon 18:07:08]
#+OPTIONS: broken-links:t
#+STARTUP: overview
# ... Present day, present time ...

* Operating System
** TODO Gentoo Linux
* Shell Environment
** Zsh
*** Environment Configuration
:PROPERTIES:
:header-args:shell: :tangle ~/.zshenv
:END:

Source system profile

#+begin_src shell
source /etc/profile
#+end_src

Need to source this file which contains locations for all my repos

#+begin_src shell
source $HOME/org/config/lib/repos
#+end_src

Update path to use my custom scripts and other locally installed scripts.

#+begin_src shell
# Update the path variable
export PATH="$HOME/org/config/bin:$PATH"
export PATH="$HOME/.local/bin/:$PATH"
export PATH="$LEDGER_DIR/bin:$PATH"
export PATH="$VIMWIKI_DIR/bin:$PATH"

# Update any system specific path settings
source $HOME/sys/path.sh 2> /dev/null
#+end_src

Collection system information

#+begin_src shell
# Get system info
export WSL=$(uname -r | grep "microsoft")
export DISTRO=$(grep --color=none ^ID= /etc/os-release \
    | sed -e 's/^ID=//g' \
    | tr -d '"')
#+end_src

Configure =less= arguments if we are in a windows linux subsystem. It doesn't support some of the standard arguments you would see in a normal =less=.

#+begin_src shell
# Override default windows less arguments
if [ -z "$WSL" ]; then
    export LESS='-R --mouse --wheel-lines=3 --no-init --quit-if-one-screen'
else
    export LESS='-R --no-init --quit-if-one-screen'
fi
#+end_src

Why am I settings my python venv directory here? This could be improved...

#+begin_src shell
# Set the python venv dir
export PYTHON_VENVS_DIR="$HOME/.local/share/python-venvs"
if [ -d "$PYTHON_VENVS_DIR" ]; then
    mkdir -p "$PYTHON_VENVS_DIR"
fi

# Specify location of ledger file
export LEDGER_FILE="$LEDGER_DIR/main.journal"
#+end_src

When using zsh inside emacs, we also need to update the editor. You definetely do not want to open up vim while inside the terminal with nearly no way to get out. Maybe I should move the alias into /not this file/.

#+begin_src shell
if [ -n "$INSIDE_EMACS" ]; then
    export VISUAL="emacsclient --socket-name=xorg-emacs-daemon"
    export EDITOR="$VISUAL"
    alias vi="$EDITOR" # lmao
fi
#+end_src

Configure Zsh command history

#+begin_src shell
HISTFILE=$HOME/.zhistory
HISTSIZE=10000
SAVEHIST=5000
#+end_src

This is sort of a weird hack. Basically, we're setting the pinentry program here before we even get to the =~/.zshrc= file. The reason is that we want pinentry to default to /GUI/ based applications instead of the /tty/. But if we enter an interactive shell environment (where =~/.zshrc= would be invoked), then we set it back to /tty/.

#+begin_src shell
#export PINENTRY_USER_DATA='rofi'
#+end_src

*** Interactive Session
:PROPERTIES:
:header-args:shell: :tangle ~/.zshrc
:END:
**** Zsh Configuration

Configure how zsh remembers history.

#+begin_src shell
setopt EXTENDED_HISTORY
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
#+end_src

Other useful defaults like auto-cd and turning off terminal beeps!

#+begin_src shell
setopt AUTO_CD
unsetopt BEEP # turn of audible beeps
#+end_src

Setup Vim Bindings in Zsh.

#+begin_src shell
bindkey -v
#+end_src

**** Load Autocompletion Engine

The directory we store the completion file will already exist due to the tangling of other zsh files.

#+begin_src shell
autoload -Uz compinit && compinit -d "$HOME/.zsh.d/compdump"
autoload -U bashcompinit && bashcompinit
#+end_src

**** Source Aliases and Functions

#+begin_src shell
source $HOME/.zsh.d/aliases.zsh
source $HOME/.zsh.d/functions.zsh
#+end_src

**** Configure SSH & GnuPG Variables

I don't know what to make of this. I thought I could have this code block in the =~/.zshenv= file but I was unable to do so as it causing many issues. Seems like it needs to be set during an interactive session. Very strange indeed.

#+begin_src shell
export GPG_TTY=$(tty)
export PINENTRY_USER_DATA='tty'
export SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket);
#+end_src

**** Setup $PS1

There are basically two ways to set prompts. My old prompt was dynamic and required a function to run everytime it generated so we used the precmd cood to generate it. However it introduces some problems with =sh= if you want to run it from =zsh=. Luckily, if you wish to run =sh= from =zsh= for whatever reason, one can simply override the hook before the command is run.

I however, am currently not using this setup, but I should configure it such that if I am in a pure terminal environment that I do in fact use my more /verbose/ prompt. In my gui environment however, that level of information is overkill.

#+begin_src shell
### NOTE: Look at the function definition for prompt_generate()
# precmd() {
#     export PROMPT=$(prompt_generate)
# }

export PS1="%F{blue}%~%f %B%(?.%F{green}.%F{red})Î»%f%b "
#+end_src

**** Override LS Colors

The =ls= command is sometimes not colored properly (and I may have some custom colors that it doesn't like using for certain files by default) so lets override that here. Maybe I should have this in the =~/.zshenv= file?

#+begin_src shell
eval $(dircolors -b $HOME/org/config/lib/shell/lscolors)
#+end_src

**** Enter a Python Virtual Environment

If certain =$VIRTUAL_ENV= exist during session startup, then immediately jump into that python virtual environment.

#+begin_src shell
if [ -n "$VIRTUAL_ENV" ]; then
    source ${VIRTUAL_ENV}/bin/activate
fi
#+end_src

**** Emacs Vterm Shell-side Integration

Woah what is a function doing here!?

Well, Vterm (emacs) requires some shell-side configuration in order to make use of its full functionality. It's quite powerful when as you can jump between prompts and other things. Basically although its a function, I'm keeping it here so that all shell-side code is in one place.

#+begin_src shell
vterm_printf() {
    if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}
#+end_src

This is used to pass information about =user=, =hostname=, and =pwd= back to vterm.

#+begin_src shell
vterm_prompt_end() {
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)";
}
setopt PROMPT_SUBST
PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'
#+end_src

Adding another zsh hook to capture changes in directory I believe. This ultimately is used to set the buffer name for vterm in emacs buffer list.

#+begin_src shell
autoload -U add-zsh-hook
add-zsh-hook -Uz chpwd (){ print -Pn "\e]2;%m:%2~\a" }
#+end_src

*** Login Script
:PROPERTIES:
:header-args:shell: :tangle ~/.zlogin
:END:

Need a logger just to keep track of things

#+begin_src shell
source $HOME/org/config/lib/shell/logger
LOGGER=$(get_logger zsh.profile)
#+end_src

Setup herbstluftwm window manager during login

#+begin_src shell
# Regular StartX Boot for Herbsluftwm
if [ -z "$DISPLAY" ] && [ "$(fgconsole 2>/dev/null)" -eq 1 ]; then
    $LOGGER "Starting xinitrc parameterized on herbstluftwm"
    export WINDOW_MANAGER='herbstluftwm'
    exec startx $HOME/.xinitrc herbstluftwm
fi
#+end_src

The remaining =tty= are for testing or recovery purposes. I primarily use =tty2= for testing new window managers. In the case below, I'm trying out emacs as a window manager.

#+begin_src shell
# Regular StartX Boot for Emacs
elif [ -z "$DISPLAY" ] && [ "$(fgconsole 2>/dev/null)" -eq 2 ]; then
    $LOGGER "Starting xinitrc parameterized on emacs"
    export WINDOW_MANAGER='exwm'
    exec startx $HOME/.xinitrc exwm
fi
#+end_src

*** Functions
:PROPERTIES:
:header-args:shell: :tangle ~/.zsh.d/functions.zsh :mkdirp yes
:END:
**** GnuPG Utilities

Simple helper function to encrypt files  with gpg

#+begin_src shell
function gpg-lock() {
    infile=$1
    if [ -z "$(echo $infile | grep -E '.+\.gpg$')" ]; then
        gpg_id=$(cat ~/.gpg-id)
        outfile="${1}.gpg"
        gpg --output $outfile -r $gpg_id --encrypt $infile
    else
        echo "Trying to encrypt already encrypted file"
    fi
}
#+end_src

Simple helper function to decrypt files with gpg

#+begin_src shell
function gpg-unlock() {
    infile=$1
    if [ -n "$(echo $infile | grep -E '.+\.gpg$')" ]; then
        outfile=$(echo ${infile} | sed -e 's/\.gpg$//g')
        gpg --output $outfile --decrypt $infile
    else
        echo "Not a valid gpg locked file; Unable to unlock!"
    fi
}
#+end_src

**** Groot

I wrote a simple script to get me details of a git repo. Absolutely pointless lol.

#+begin_src shell
function groot() {
    GITROOT=$(git rev-parse --show-toplevel 2> /dev/null);
    ROOTEXIST=$?

    if [ $ROOTEXIST -eq 0 ]; then

        cd $GITROOT;
        NAME=$(basename -s .git `git config --get remote.origin.url` 2> /dev/null)

        if [ -z "$NAME" ]; then
            NAME="[ ]"
        fi

        BRANCH=$(git branch --list --no-color | cut -d " " -f 2 | tr -d '\n');
        figlet -t -f slant $@ "${NAME} @.${BRANCH}" | lolcat

        git status
    fi
}
#+end_src

**** One of my many prompts

I really like this prompt. I should probably set this up such that it's only used when I'm using the =tty=. Here is what is normally looks like:

#+begin_src
.-|ssh|-(amlesh@xanadu)-[debian::~/src/website]-<website.master>
`-->
#+end_src

#+begin_src shell
function prompt_generate() {
    echo -ne "%B%F{cyan}.-"

    # Check if we are in an SSH connection
    if [ -n "$SSH_TTY" ]; then
        echo -ne "%F{black}|%b%F{blue}ssh%F{black}%B|%F{cyan}-"
    fi

    # user @ hostname
    echo -ne "%F{black}(%b%F{cyan}%n%F{white}@%F{magenta}%M%F{black}%B)"

    # distro :: current working directory
    echo -ne "%F{cyan}-%F{black}[%b%F{cyan}${DISTRO}"
    echo -ne "%F{white}::%F{blue}%~%B%F{black}]"

    if [ -d "`git rev-parse --show-toplevel 2> /dev/null`/.git" ]; then

        GIT_NAME=$(basename -s .git `git config --get remote.origin.url` \
            2> /dev/null)
        GIT_NAME=$(echo $GIT_NAME | sed -e 's|^.*:||g')

        if [ -z "$GIT_NAME" ]; then
            GIT_NAME="[?]"
        fi

        GIT_BRANCH=$(git branch --list --no-color | grep --color=auto '\*' \
            | sed -e 's/^\* //g' | head -n1 | tr -d '\n')

        # (yes/no add ; no commited)
        #YA=$(git status --porcelain 2>/dev/null| egrep "^M" | wc -l)
        #NA=$(git status --porcelain 2>/dev/null| egrep "^ M" | wc -l)
        NC=$(git status --porcelain 2>/dev/null| egrep "^(M| M | D)" | wc -l)

        # Use this info to construct our real status
        if [ $NC -eq 0 ]; then
            C='green'
        else
            C='red'
        fi
        echo -ne "%F{cyan}-%F{black}<%b%F{$C}$GIT_NAME.$GIT_BRANCH%B%F{black}>"

    fi
    if [ -n "${ENV_NAME}${PIPENV_ACTIVE}${VIRTUAL_ENV}" ]; then

        echo -ne "%F{cyan}-%F{black}{%b%F{yellow}"
        MOD=""

        if [ -n "$VIRTUAL_ENV" ]; then
            # Support both the old way of using venvs and new way
            echo -ne "venv:$(basename $VIRTUAL_ENV /.venv)"
            MOD="/"
        fi

        if [ -n "$PIPENV_ACTIVE" ]; then
            echo -ne "${MOD}pipenv"
            MOD="/"
        fi

        if [ -n "$ENV_NAME" ]; then
            echo -ne "$MOD$ENV_NAME"
        fi

        echo -ne "%B%F{black}}"
    fi
    echo -ne "\n"
    echo -ne "%F{cyan}\`--%B%F{white}> %{\e[0m%}"
}
#+end_src

**** Python Venv Wrapper

There may be a better solution to this, but I just like using the built in =venv= that is part of =python3=. But its a pain to write out every command so this does a lot of things.

#+begin_src shell
function venv() {
    # A simple wrapper for virtualenv
    PYTHON_VENVS_DIR=${PYTHON_VENVS_DIR:-$HOME/.venvs}
    if [[ ! -z "$@" ]]; then
        vname=$1;
        shift;
        if [[ -z "$@" ]]; then
            if [[ ! -d "$PYTHON_VENVS_DIR/$vname" ]]; then
                echo "Create a new virtual environment named '$vname' ?";
                echo 'Press any key to continue or Ctrl+C to exit...\n'
                # note this is zsh read
                read -k1 -rs
                echo "Creating new venv: $vname";
                python -m venv $PYTHON_VENVS_DIR/$vname
            fi
            echo "Starting venv: $vname"
            source $PYTHON_VENVS_DIR/${vname}/bin/activate
            save_window_info
        else
            python -m venv $PYTHON_VENVS_DIR/$vname $@
            save_window_info
        fi
    else
        echo "Python Virtual Environments (venvs)"
        tree -L 1 -d --noreport $PYTHON_VENVS_DIR/ | tail -n +2
    fi
}
#+end_src

**** X Window Terminal Info

Basically this lets me open up new windows withing the same directory that another existing terminal is in (so I don't have to =cd= into it). This works by a couple of hacks. Save window information for each x-window terminal session when we spawn it. Override the default =cd= so that we also save every directory change. We also save python venv information as well. We also want to make sure we only do this when an X11 display exists.

#+begin_src shell
function window_info() {
    echo "WINDOW_PWD='$(pwd)'";
    echo "VIRTUAL_ENV='${VIRTUAL_ENV}'";
}
#+end_src

#+begin_src shell
function save_window_info() {
    window_info > /tmp/.wid_${WINDOWID}
}
#+end_src

Overrides default =cd= and also saves the terminal info at initial startup

#+begin_src shell
if [ -n "$DISPLAY" ]; then
    # Build our custom cd
    function cd () {
        builtin cd $@
        save_window_info
    }
    # Every terminal should generate its id file on spawn
    if [ -z "$WINDOWID" ]; then
        # echo "Terminal doesn't have a Window ID!!!"
    else
        save_window_info
    fi
fi
#+end_src

**** Universal Extract Script

#+begin_src shell
function ext() {
    # Make sure some argument is given
    if [ ! -f "$1" ] ; then
        echo "'$1' does not exist."
        return 1
    fi
    # based on filetype, extract the file
    case "$1" in
        ,*.tar.bz2)   tar xvjf "$1"   ;;
        ,*.tar.xz)    tar xvJf "$1"   ;;
        ,*.tar.gz)    tar xvzf "$1"   ;;
        ,*.bz2)       bunzip2 "$1"    ;;
        ,*.rar)       rar x "$1"      ;;
        ,*.gz)        gunzip "$1"     ;;
        ,*.tar)       tar xvf "$1"    ;;
        ,*.tbz2)      tar xvjf "$1"   ;;
        ,*.tgz)       tar xvzf "$1"   ;;
        ,*.zip)       unzip "$1"      ;;
        ,*.Z)         uncompress "$1" ;;
        ,*.xz)        xz -d "$1"      ;;
        ,*.7z)        7z x "$1"       ;;
        ,*.a)         ar x "$1"       ;;
        ,*)           echo "Unable to extract '$1'." ;;
    esac

}
#+end_src

*** Aliases
:PROPERTIES:
:header-args:shell: :tangle ~/.zsh.d/aliases.zsh :mkdirp yes
:END:

Shortcuts for =ls=

#+begin_src shell
alias ls="LC_COLLATE=C ls -F --color=always"
alias ll="ls -oh"
alias la="ls -lah"
#+end_src

Shortcuts for =git=

#+begin_src shell
alias gs="git status"
alias ga="git add"
alias gc="git commit"
alias gd="git diff"
alias gds="git diff --staged"
alias gl="git log --graph --stat -p"
alias gp="git push"
alias gf="git fetch"
alias gm="git merge"
alias gb="git branch -av"
#+end_src

These aliases are weird. This was when the term I was using was causing issues with =clear= and other utilities like =eselect=. The problem however was that I couldn't just set the =TERM= to /xterm/ globally as other utilities would also break.

#+begin_src shell
alias clear="TERM='xterm' clear"
alias eselect="TERM='xterm' eselect"
#+end_src

Make various commands pretty by default

#+begin_src shell
alias grep="grep --color=always"
alias tree="tree -C"
alias dog="pygmentize"
#+end_src

Misc things

#+begin_src shell
alias fping="ping -c 3 www.google.com"
alias weather="curl wttr.in"
#+end_src

Ricing info commands

#+begin_src shell
alias info="clear;echo;neofetch;colors;"
alias infos="info;scrot --delay 3 --count --quality 100 ~/tmp/myscrot.png"
#+end_src

Sudo improvements...

#+begin_src shell
alias please="sudo"
if [ $UID -ne 0 ]; then
    alias fuck='eval "sudo $(fc -ln -1)"'
fi
#+end_src

Make certain commands safer to use by default

#+begin_src shell
alias rm="rm -I --preserve-root"
alias mv="mv -i"
alias cp="cp -i"
#+end_src

** GnuPG
*** GPG
:PROPERTIES:
:header-args:conf: :tangle ~/.gnupg/gpg.conf :mkdirp yes
:END:

#+begin_src conf
# When outputting certificates, view user IDs distinctly from keys
fixed-list-mode

# Long keyids are more collision-resistant than short keyids
# (Its trivial to make a key with any desired short keyid)
keyid-format 0xlong
with-fingerprint

# when multiple digests are supported by all recipients, choose the strongest one:
personal-digest-preferences SHA512 SHA384 SHA256 SHA224

# preferences chosen for new keys should prioritize stronger algorithms:
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 BZIP2 ZLIB ZIP Uncompressed

# If you use a graphical environment (and even if you don't) you should be
# using an agent: (similar arguments as
# https://www.debian-administration.org/users/dkg/weblog/64)
use-agent

# You should always know at a glance which User IDs gpg thinks are
# legitimately bound to the keys in your keyring:
verify-options show-uid-validity
list-options show-uid-validity

# when making an OpenPGP certification, use a stronger digest than the default SHA1:
cert-digest-algo SHA256

# prevent version string from appearing in your signatures/public keys
no-emit-version
#+end_src

*** GPG Agent
:PROPERTIES:
:header-args:conf: :tangle ~/.gnupg/gpg-agent.conf :mkdirp yes
:END:

#+begin_src conf
default-cache-ttl 600
max-cache-ttl 7200
enable-ssh-support
pinentry-program /usr/bin/pinentry-switcher

# This means clients like Emacs can get the password in their own way
# and push to gpg. For this to work with emacs, set `epa-pinentry-mode`
# to `'loopback` in Emacs
allow-emacs-pinentry
allow-loopback-pinentry
#+end_src

** OpenSSH
:PROPERTIES:
:header-args:conf: :tangle ~/.ssh/config :mkdirp yes
:END:
*** GnuPG Connect Agent

Since we are using GPG agent as the SSH agent, when in a terminal, ssh agent doesn't know that it has to change terminals (a bug in openssh). So when it connects to gpg-agent, it uses the terminal it was last configured to use. The following command when run in a terminal updates gpg-agent to use the current terminal for openssh. However, now if we run some ssh related command in the prior terminal, it will use the new terminal instead creating the exact inverse of the problem. Therefore we attempt to fix this by running this command before every SSH command.

[[https://bugzilla.mindrot.org/show_bug.cgi?id=2824#c9][https://bugzilla.mindrot.org/show_bug.cgi?id=2824#c9]]

#+begin_src conf
Match host * exec "gpg-connect-agent --no-autostart UPDATESTARTUPTTY /bye"
#+end_src

** Isync & Mbsync
:PROPERTIES:
:header-args:conf: :tangle ~/.mbsyncrc
:END:

A tool used to sync and create local IMAP stores.

#+begin_src conf
IMAPAccount gmail
Host imap.gmail.com
User samlesh@gmail.com
PassCmd "pass email/samlesh@gmail.com-app-isync"
SSLType IMAPS
CertificateFile /etc/ssl/certs/ca-certificates.crt

IMAPStore gmail-remote
Account gmail

MaildirStore gmail-local
Subfolders Verbatim
# The trailing "/" is important!
Path ~/.mail/samlesh@gmail.com/
Inbox ~/.mail/samlesh@gmail.com/Inbox

Channel gmail
Master :gmail-remote:
Slave :gmail-local:
Patterns *
Create Both
SyncState *
#+end_src

** Neovim
:PROPERTIES:
:header-args:conf: :tangle ~/.config/nvim/init.vim :mkdirp yes
:END:
*** Load Vim Plugins (VimPlug)

#+begin_src conf
call plug#begin('~/.vim/plugged')

" vim-airline:
" Lean & mean status/tabline for vim thats light as air
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'morhetz/gruvbox'

Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'

Plug 'jamessan/vim-gnupg'
Plug 'chrisbra/csv.vim'
Plug 'godlygeek/tabular'
Plug 'plasticboy/vim-markdown'
Plug 'vimwiki/vimwiki', { 'branch': 'dev' }
Plug 'mattn/calendar-vim'

" Plug 'valloric/youcompleteme'
Plug 'yggdroot/indentline'
Plug 'mbbill/undotree'

" Language Based Plugins
Plug 'JuliaEditorSupport/julia-vim'
Plug 'ledger/vim-ledger'
Plug 'nathangrigg/vim-beancount'
Plug 'vim-scripts/gnuplot.vim'

call plug#end()
#+end_src

*** Configure loaded plugins
**** Vim Airline

#+begin_src conf
" vim-airline
let laststatus = 2
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1

" vim-airline-themes
let g:airline_theme = 'base16_gruvbox_dark_hard'
#+end_src

**** Git Gutter

#+begin_src conf
" git-gutter
nmap <C-M-j> <Plug>GitGutterNextHunk
nmap <C-M-k> <Plug>GitGutterPrevHunk
let g:gitgutter_set_sign_backgrounds = 1
#+end_src

**** Indent Lines

#+begin_src conf
" Indent Lines
"let g:indentLine_char = '.'
let g:indentLine_char_list = ['|', 'Â¦', 'â', 'â']
let g:indentLine_setColors = 1
"let g:indentLine_bgcolor_term = 0
let g:indentLine_color_term = 8
let g:indentLine_conceallevel = 2
let g:indentLine_concealcursor = "n"
#+end_src

**** Vim Ledger

#+begin_src conf
" Configure vim ledger
let g:ledger_maxwidth = 80
let g:ledger_bin = 'ledger'
let g:ledger_extra_options = '--pedantic --explicit'
let g:ledger_align_at = 77
let g:ledger_date_format = '%Y-%m-%d'
#+end_src

**** Markdown

#+begin_src conf
" Markdown conceal
let g:vim_markdown_conceal = 0
let g:vim_markdown_conceal_code_blocks = 0
#+end_src

**** Vim Wiki

#+begin_src conf
" Vim Wiki
let personal_wiki = {}
let personal_wiki.name = 'Tabula Rasa'
let personal_wiki.path = '~/usr/wiki/src'
let personal_wiki.path_html = '~/usr/wiki/.html'
let personal_wiki.syntax = 'markdown'
let personal_wiki.ext = '.md'
let personal_wiki.maxhi = 1
let personal_wiki.diary_rel_path = "journal/"
let personal_wiki.diary_index = "toc"
let personal_wiki.diary_header = "Personal Journal"
let personal_wiki.diary_caption_level = 0
let personal_wiki.auto_diary_index = 1

let g:vimwiki_list = [personal_wiki]
let g:vimwiki_global_ext = 1
let g:vimwiki_listsyms = ' ââââ' " 'âââââ'
let g:vimwiki_folding = 'expr'
let g:vimwiki_hl_cb_checked = 2
#+end_src

*** Setup Sane Vim Defaults

#+begin_src conf
set nocompatible
set number          " Show Line numbers
set ruler           " Show line and column number of the cursor
set cursorline      " highlight current line
set cursorcolumn    " Create a column for where the cursor is
set colorcolumn=80  " Create a column to show where 80 chars are
set modeline        " Allow source files to configure vim as well
set nowrap

" TAB = 4 SPACES
set tabstop=4		" number of visual spaces per TAB
set softtabstop=4   " number of space in TAB while editing
set expandtab		" TABs are now SPACEs
set shiftwidth=4    " Allows helps to make it 4 spaces in neovim

filetype plugin on
filetype indent on  " Load filetype-specific indent files
syntax on

set wildmenu        " visual autocomplete for command menu
set lazyredraw      " redraw only when we need to

set showmatch       " highlight matching brackets [{()}]
set incsearch       " search as characters are entered
set hlsearch        " highlight matches

set noshowmode      " Stop showing the default mode

set mouse=a         " Set mouse wheel to scroll

" Code concealing
set conceallevel=2
set concealcursor-=n

" Enable Code Folding
set foldenable
set foldlevelstart=10
set foldnestmax=10
set foldmethod=indent    " fold based on ident level

" Custom file search
set path+=**
#+end_src

*** Vim Colorschemes

#+begin_src conf
" Use peachpuff built-in colorscheme as the base
colorscheme peachpuff

" Color of the Columns
highlight ColorColumn ctermbg=black
highlight CursorColumn ctermbg=black
highlight VertSplit ctermfg=black

" Change the default coloring of line numbers
highlight LineNr ctermfg=black

" Change colorscheme of Pmenus
highlight Pmenu ctermfg=darkgrey ctermbg=black

" Set background color of folded blocks
highlight Folded ctermbg=black

" Some syntax highlighting changes (maybe move this to its own file)
highlight Function ctermfg=darkblue
highlight String ctermfg=darkgreen
highlight Comment ctermfg=darkgrey
highlight Exception ctermfg=darkred

" Fix colors on gitgutter after colorscheme has been set
highlight SignColumn ctermbg=None
highlight GitGutterAdd ctermbg=None ctermfg=green
highlight GitGutterChange ctermbg=None ctermfg=yellow
highlight GitGutterDelete ctermbg=None ctermfg=red

" Change colors to be more intuitive for vimwiki
highlight VimwikiHeader1 ctermbg=None ctermfg=darkred
highlight VimwikiHeader2 ctermbg=None ctermfg=darkblue
highlight VimwikiHeader3 ctermbg=None ctermfg=darkgreen
highlight VimwikiHeader4 ctermbg=None ctermfg=yellow
highlight VimwikiHeader5 ctermbg=None ctermfg=cyan
highlight VimwikiHeader6 ctermbg=None ctermfg=magenta

highlight Conceal ctermbg=None ctermfg=darkblue
#+end_src

*** Custom Keybindings

#+begin_src conf
" Sets a keybind to turn off highlighted searches
nnoremap <leader><space> :nohlsearch<CR>

" Keybinds to quickly switch buffers
noremap <S-j> :bn<CR>
noremap <S-k> :bp<CR>

" Custom git mappings (is fugitive or gitgutter better to use instead?)
noremap <F2> :Git <CR>
noremap <F3> :Git diff<CR>
noremap <F4> :Gclog<CR>

" Key binds to toggle the Undo Tree
noremap <F5> :UndotreeToggle<CR>

noremap <F6> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") .
    \ '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
    \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">" .
    \ " FG:" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"fg#")<CR>

" Ledger remap tab completion
au FileType ledger inoremap <silent> <Tab>
            \ <C-r>=ledger#autocomplete_and_align()<CR>
au FileType ledger vnoremap <silent> <Tab>
            \ :LedgerAlign<CR>
au FileType ledger nnoremap <silent> <C-m>
            \ :silent<space>make<bar>redraw!<bar>cwindow<CR>
au FileType ledger nnoremap <silent> <C-s>
            \ :call ledger#transaction_state_toggle(line('.'), ' !*?')<CR>

" Vimwiki doc pubs open
autocmd FileType vimwiki nnoremap <Leader>p :silent !pubs doc open %:r<CR>
#+end_src

*** Custom Vim Functions
**** Trim Whitespace
#+begin_src conf
" Trim the whitespace present in a file
fun! TrimWhitespace()
    let l:save = winsaveview()
    keeppatterns %s/\s\+$//e
    call winrestview(l:save)
endfun
command! TrimWhitespace call TrimWhitespace()
#+end_src

**** Toggle Calendar

#+begin_src conf
" Toggle calendar view within view if in vim wiki
function! ToggleCalendar()
    execute ":Calendar"
    if exists("g:calendar_open")
        if g:calendar_open == 1
            execute "q"
            unlet g:calendar_open
        else
            g:calendar_open = 1
        end
    else
        let g:calendar_open = 1
    end
endfunction
:autocmd FileType vimwiki map <leader>c :call ToggleCalendar()<CR>
#+end_src

*** Vim mode line

#+begin_src conf
" vim:ft=vim
#+end_src

** Tmux
:PROPERTIES:
:header-args:conf: :tangle ~/.tmux.conf
:END:
*** Basic Config

#+begin_src conf
set -g default-terminal "screen-256color"   # Use 256 colors
set -g history-limit 100000                 # Scrollback buffer number of lines

# Start window indexing at one instead of zero
set -g base-index 1
#+end_src

*** Keybindings

#+begin_src conf
# Set the prefix key and some key bindings to match GNU Screen
set -g prefix C-b
#bind-key C-a last-window

# Key bindings for horizontal and vertical panes
unbind %
unbind '"'
bind | split-window -h
bind - split-window -v

# Add vim-like bindings
unbind-key j
bind-key j select-pane -D
unbind-key k
bind-key k select-pane -U
unbind-key h
bind-key h select-pane -L
unbind-key l
bind-key l select-pane -R
#+end_src

*** Window Settings

#+begin_src conf
# Enable window titles
set -g set-titles on

# Window title string (uses statusbar variables)
set -g set-titles-string '#T'
#+end_src

*** Status Bar

#+begin_src conf
# Status bar with load and time
set -g status-bg '#4e4e4e'
set -g status-fg '#ffffff'
set -g status-left ' '
set -g status-right '#[bg=#bbbbbb]#[fg=#000000]#(cut -d " " -f -3 /proc/loadavg) #[bg=#4e4e4e]#[fg=#ffffff]#(date +" %H:%M ")'
set -g window-status-format '#I #W'
set -g window-status-current-format ' #I #W '
setw -g window-status-current-bg '#55ff55'
setw -g window-status-current-fg '#000000'
#+end_src

*** Pane

#+begin_src conf
# Pane border colors
set -g pane-active-border-fg '#bbbbbb'
set -g pane-border-fg '#555555'
#+end_src

*** Reload Config

#+begin_src conf
# Bind to reload config
bind r source-file ~/.tmux.conf
#+end_src

* Desktop Environment
** Window Manager Utilties Startup Script
:PROPERTIES:
:header-args: :noweb-ref wm-util-startup
:END:

This is the main script outside of the actual window mangaer which is triggered by xorg. The purpose of this is to put other programs that need to be started alongside the window manager to create a fully fledged desktop environment. Typically, I've seen these components be in the =~/.xinitrc= file but we don't really want to restart xorg if we want to run some of the initialization code. The other option is to put it in the init file for the window manager, but that would also mean that we have to copy the same code to other init files. Instead its better for it to just have a unified source.

Secondaly, these codeblocks aren't actually tangled anywhere directly. We use =org-babel='s no-web feature which lets us insert code blocks into other code blocks. For example, we insert it into the *herbstluftwm* autostart config.

Like with all other components in my system, setup a logger for debugging purposes.

#+begin_src shell
# We may already have a logger ready to use...
if [ -z "$LOGGER" ]; then
    . $HOME/org/config/lib/shell/logger
    LOGGER=$(get_logger xorg.wminit)
fi
$LOGGER "Initializing window manager common utilities"
#+end_src

Start compton if a config file exists. Looks crisp as hell!

#+begin_src shell
pkill -x compton
if [ -f "$HOME/.config/compton.conf" ]; then
    $LOGGER "Starting Compton"
    compton &
fi
#+end_src

Make sure xrdb loads up the xresouces file

#+begin_src shell
# Reload the xresource data
xrdb -I$HOME $HOME/.Xresources
#+end_src

I had =xst= terminal installed as it was a lightweight alternative to urxvt. If I ever do continue using it, make sure it gets the config reset switch. *NOTE:* this wil fail if the colorscheme isn't properly set!

#+begin_src shell
# Refresh the terminal
pkill -USR1 xst
#+end_src

If I was still using =rxvt-unicode='s daemon, this would be uncommented...

#+begin_src shell
# if [ -z "$(pgrep urxvtd)" ]; then
#     urxvtd -q -o -f
# fi
#+end_src

*Very Important!* Make sure we start the emacs daemon here! But do not start it if it's already running.

#+begin_src shell
if [ -z "$(pgrep -f 'emacs --daemon=xorg-emacs-daemon')"]; then
    emacs --daemon=xorg-emacs-daemon
fi
#+end_src

Set the background for the desktop environment. If =~/.fehbg= doesn't exist, setup the bitmap wallpaper.

#+begin_src shell
# Set the background
if [ -f "$HOME/.fehbg" ]; then
    $HOME/.fehbg
else
    . $HOME/org/config/lib/shell/xrdb_colors
    xsetroot -bitmap ~/org/config/lib/bitmaps/tile.xbm -fg $XCOLOR0 -bg $XBACKGROUND
fi
#+end_src

I use =sxhkd= for keybindings that should exist in all my environments regardless of what window manager I'm using.

#+begin_src shell
# Initialize universal keybindings
SXHKD_SHELL=sh
export SXHKD_TERMINAL=$HOME/org/config/bin/emacsclient-launcher
pkill -x sxhkd
sxhkd &
#+end_src

The single most important thing! Make the *CAPS LOCK* key into the *ESCAPE* key!

#+begin_src shell
setxkbmap -option caps:escape
#+end_src

We need to configure various xorg settings here. This might not be the best place as this definetly feels like something that should belong in the =~/.xinitrc=, however, in case they are set to something other than the defaults, it makes sense to be able to reset them here.

#+begin_src shell
# Use Display Power Management Settings to configure various things.
# + Disable screen blanking (screensaver) (I don't think this works)
xset s off

# + Increases the speed of the keyboard repeat rate
xset r rate 400 50

# Rehash local fonts
xset +fp $HOME/.local/share/fonts
xset fp rehash
#+end_src

Finally start lemonbar once everything else is setup.

#+begin_src shell
# Start lemonbar after all X related stuff is finished
pkill -x lemonbar
$HOME/.config/lemonbar/lemonbar &
#+end_src

** Xorg X11 Window System
*** Xinitrc
:PROPERTIES:
:header-args:shell: :tangle ~/.xinitrc :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/org/config/lib/shell/logger
LOGGER=$(get_logger xinitrc)
#+end_src

Some linux distros have predefined scripts in these locations that need to be sourced in order for proper Xorg operation. Source the global defaults and then the local files if any exist.

#+begin_src shell
# We need to source some things if it exists
$LOGGER "Sourcing xinitrc.d files if they exist"
if [ -d /etc/X11/xinit/xinitrc.d ] ; then
    for f in /etc/X11/xinit/xinitrc.d/*.sh ; do
        [ -x "$f" ] && . "$f"
    done
    unset f
fi

# Repeat for any local scripts if they exist
# Store xrandr monitor setup scripts here!!!
if [ -d $HOME/.config/xinitrc.d ] ; then
    find "$HOME/.config/xinitrc.d" -name "*.sh" | while read -r f; do
        [ -x "$f" ] && . "$f"
    done
    unset f
fi
#+end_src

This part of the script decides which window manager to start. This is ultimately passed as an argument to startx. Take a look at =~/.zlogin= to see how it is triggered.

#+begin_src shell
# Start Window Manager
session=${1:-herbstluftwm}
$LOGGER "Starting session: $session"

EXEC_DBUS="exec dbus-launch --exit-with-session"

case $session in
    herbstluftwm)   $EXEC_DBUS herbstluftwm;;
    exwm)           $EXEC_DBUS emacs -mm --debug-init;;
    *)              exec $1;;
esac
#+end_src

*** Xresources
:PROPERTIES:
:header-args:C: :tangle ~/.Xresources
:END:
**** Source Colorscheme

#+begin_src C
#include ".config/xcolor/scheme"
#+end_src

**** Xft Font Settings

#+begin_src C
Xft.dpi:                    96
Xft.antialias:              true
Xft.rgba:                   rgb
Xft.hinting:                true
Xft.hintstyle:              hintslight
#+end_src

**** Default Font Face

#+begin_src C
!*font: xft:Iosevka Term:size=11
!*font: xft:xos4 Terminus:size=12
#define system_font xft:xos4 Terminus:size=12
#+end_src

**** Rxvt Unicode Terminal
***** General Settings

#+begin_src C
URxvt.depth:                32
URxvt.geometry:             96x33
URxvt.loginShell:           false
URxvt.internalBorder:       10
URxvt.lineSpace:            0
!URxvt.termName:             xterm-256color
#+end_src

***** Transparency

I've disabled all transparency for the time being

#+begin_src C
! fake transparency - true or false (default)
!URxvt*transparent: true

! Real transparency (needs compositor like compton)
! If using make sure to disable the background below.
!URxvt*depth: 32
!URxvt*background: [85]xbackground
#+end_src

***** Misc UI Changes

#+begin_src C
! tint with any color; i.e., blue, red, tomato4, olivedrab2, etc.
!   some nice listings are at:
!     http://www.nisrv.com/drupal/?q=node/11
!     http://www.htmlgoodies.com/tutorials/colors/article.php/3478921
!URxvt*tintColor: S_base03

! shading - 0 to 99 darkens, 101 to 200 lightens.
!   Dont use with tintColor; just use a darker or lighter color instead.
URxvt*shading: 15

URxvt*saveLines: 12000

! scrollbar - true (default) or false
URxvt*scrollBar: false

! scrollbar position - left=false (default) or right=true
URxvt*scrollBar_right: false

! scrollbar style - rxvt (default), plain, next, or xterm
URxvt*scrollstyle: plain
#+end_src

***** Clipboard Keybindings

#+begin_src C
! Remap the copy and paste functionaility
URxvt.keysym.Shift-Control-V: eval:paste_clipboard
URxvt.keysym.Shift-Control-C: eval:selection_to_clipboard
#+end_src

***** Colorscheme and Font

#+begin_src C
URxvt.foreground: xforeground
URxvt.background: xbackground
URxvt.cursorColor: xcursorColor

! This is for fading windows if not active
URxvt.fading: xfade
URxvt.fadeColor: xbackground

URxvt.color0:  xcolor0
URxvt.color1:  xcolor1
URxvt.color2:  xcolor2
URxvt.color3:  xcolor3
URxvt.color4:  xcolor4
URxvt.color5:  xcolor5
URxvt.color6:  xcolor6
URxvt.color7:  xcolor7
URxvt.color8:  xcolor8
URxvt.color9:  xcolor9
URxvt.color10: xcolor10
URxvt.color11: xcolor11
URxvt.color12: xcolor12
URxvt.color13: xcolor13
URxvt.color14: xcolor14
URxvt.color15: xcolor15

URxvt.font: system_font
#+end_src

**** Rofi Dmenu
***** Enabled Modes

#+begin_src C
! "Enabled modi" Set from: Default
rofi.modi:                           window,run,ssh
#+end_src

***** Window Geometry

#+begin_src C
! "Window width" Set from: Default
 rofi.width:                          30

! "Number of lines" Set from: Default
 rofi.lines:                          15

! "Number of columns" Set from: Default
! rofi.columns:                        1
#+end_src

***** Colorscheme and Font

#+begin_src C
! "Font to use" Set from: XResources
rofi.font:                            Iosevka Term 12

! Color Guidlines                       BG -  FG - BG_ALT - HL_BG - HL_FG
! "Color scheme for normal row"
 rofi.color-normal:                     xbackground, xforeground, xbackground, xcolor0, xforeground
! "Color scheme for urgent row"
 rofi.color-urgent:                     xbackground, xforeground, xbackground, xcolor0, xforeground
! "Color scheme for active row"
 rofi.color-active:                     xbackground, xforeground, xbackground, xcolor0, xforeground

! Color Guidlines                       BG          BORDER      SEPEARATOR
! "Color scheme window"
 rofi.color-window:                     xbackground,    xcolor8,    xcolor8
! "Border width" Set from: XResources
rofi.bw:                             4
#+end_src

***** Unused Rofi Settings

#+begin_src C
! "Location on screen" Set from: Default
! rofi.location:                       0
! "Padding" Set from: Default
! rofi.padding:                        5
! "Y-offset relative to location" Set from: Default
! rofi.yoffset:                        0
! "X-offset relative to location" Set from: Default
! rofi.xoffset:                        0
! "Always show number of lines" Set from: Default
! rofi.fixed-num-lines:                true

! "Terminal to use" Set from: XResources
rofi.terminal:                       urxvtc
! "Ssh client to use" Set from: Default
! rofi.ssh-client:                     ssh
! "Ssh command to execute" Set from: Default
! rofi.ssh-command:                    {terminal} -e {ssh-client} {host}
! "Run command to execute" Set from: Default
! rofi.run-command:                    {cmd}
! "Command to get extra run targets" Set from: Default
! rofi.run-list-command:
! "Run command to execute that runs in shell" Set from: Default
! rofi.run-shell-command:              {terminal} -e {cmd}
! "Command executed on accep-entry-custom for window modus" Set from: Default
! rofi.window-command:                 xkill -id {window}

! "Disable history in run/ssh" Set from: Default
! rofi.disable-history:                false
! "Use levenshtein sorting" Set from: Default
! rofi.levenshtein-sort:               false
! "Set case-sensitivity" Set from: Default
! rofi.case-sensitive:                 false

! "Cycle through the results list" Set from: Default
! rofi.cycle:                          true
! "Enable sidebar-mode" Set from: Default
! rofi.sidebar-mode:                   false
! "Row height (in chars)" Set from: Default
! rofi.eh:                             1
! "Enable auto select mode" Set from: Default
! rofi.auto-select:                    false

! "Parse hosts file for ssh mode" Set from: Default
! rofi.parse-hosts:                    false
! "Parse known_hosts file for ssh mode" Set from: Default
! rofi.parse-known-hosts:              true

! "Set the modi to combine in combi mode" Set from: Default
! rofi.combi-modi:                     window,run
! "Set the matching algorithm. (normal, regex, glob, fuzzy)" Set from: Default
! rofi.matching:                       normal
! "Tokenize input string" Set from: Default
! rofi.tokenize:                       true
! "Monitor id to show on" Set from: Default
! rofi.m:                              -5

! "Margin between rows" Set from: Default
! rofi.line-margin:                    2
! "Padding within rows" Set from: Default
! rofi.line-padding:                   1
! "Pre-set filter" Set from: Default
! rofi.filter:
! "Separator style (none, dash, solid)" Set from: Default
! rofi.separator-style:                dash
! "Hide scroll-bar" Set from: Default
! rofi.hide-scrollbar:                 false
! "Fullscreen" Set from: Default
! rofi.fullscreen:                     false
! "Fake transparency" Set from: Default
! rofi.fake-transparency:              false
! "DPI" Set from: Default
! rofi.dpi:                            -1

! "Threads to use for string matching" Set from: Default
! rofi.threads:                        0

! "Scrollbar width" Set from: Default
! rofi.scrollbar-width:                8
! "Scrolling method. (0: Page, 1: Centered)" Set from: Default
! rofi.scroll-method:                  0

! "Background to use for fake transparency. (background or screenshot)" Set from: Default
! rofi.fake-background:                screenshot
! "Window Format. w (desktop name), t (title), n (name), r (role), c (class)" Set from: Default
! rofi.window-format:                  {w}   {c}   {t}
! "Click outside the window to exit" Set from: Default
! rofi.click-to-exit:                  true

! "Indicate how it match by underlining it." Set from: Default
! rofi.show-match:                     true
! "Pidfile location" Set from: Default
! rofi.pid:                            /home/zamlz/.cache/rofi.pid

! "Paste primary selection" Set from: Default
! rofi.kb-primary-paste:               Control+V,Shift+Insert
! "Paste clipboard" Set from: Default
! rofi.kb-secondary-paste:             Control+v,Insert
! "Clear input line" Set from: Default
! rofi.kb-clear-line:                  Control+w
! "Beginning of line" Set from: Default
! rofi.kb-move-front:                  Control+a
! "End of line" Set from: Default
! rofi.kb-move-end:                    Control+e
! "Move back one word" Set from: Default
! rofi.kb-move-word-back:              Alt+b
! "Move forward one word" Set from: Default
! rofi.kb-move-word-forward:           Alt+f
! "Move back one char" Set from: Default
! rofi.kb-move-char-back:              Left,Control+b
! "Move forward one char" Set from: Default
! rofi.kb-move-char-forward:           Right,Control+f
! "Delete previous word" Set from: Default
! rofi.kb-remove-word-back:            Control+Alt+h,Control+BackSpace
! "Delete next word" Set from: Default
! rofi.kb-remove-word-forward:         Control+Alt+d
! "Delete next char" Set from: Default
! rofi.kb-remove-char-forward:         Delete,Control+d
! "Delete previous char" Set from: Default
! rofi.kb-remove-char-back:            BackSpace,Control+h
! "Delete till the end of line" Set from: Default
! rofi.kb-remove-to-eol:               Control+k
! "Delete till the start of line" Set from: Default
! rofi.kb-remove-to-sol:               Control+u
! "Accept entry" Set from: Default
! rofi.kb-accept-entry:                Control+j,Control+m,Return,KP_Enter
! "Use entered text as command (in ssh/run modi)" Set from: Default
! rofi.kb-accept-custom:               Control+Return
! "Use alternate accept command." Set from: Default
! rofi.kb-accept-alt:                  Shift+Return
! "Delete entry from history" Set from: Default
! rofi.kb-delete-entry:                Shift+Delete
! "Switch to the next mode." Set from: Default
! rofi.kb-mode-next:                   Shift+Right,Control+Tab
! "Switch to the previous mode." Set from: Default
! rofi.kb-mode-previous:               Shift+Left,Control+Shift+Tab
! "Go to the previous column" Set from: Default
! rofi.kb-row-left:                    Control+Page_Up
! "Go to the next column" Set from: Default
! rofi.kb-row-right:                   Control+Page_Down
! "Select previous entry" Set from: Default
! rofi.kb-row-up:                      Up,Control+p,Shift+Tab,Shift+ISO_Left_Tab
! "Select next entry" Set from: Default
! rofi.kb-row-down:                    Down,Control+n
! "Go to next row, if one left, accept it, if no left next mode." Set from: Default
! rofi.kb-row-tab:                     Tab
! "Go to the previous page" Set from: Default
! rofi.kb-page-prev:                   Page_Up
! "Go to the next page" Set from: Default
! rofi.kb-page-next:                   Page_Down
! "Go to the first entry" Set from: Default
! rofi.kb-row-first:                   Home,KP_Home
! "Go to the last entry" Set from: Default
! rofi.kb-row-last:                    End,KP_End
! "Set selected item as input text" Set from: Default
! rofi.kb-row-select:                  Control+space
! "Take a screenshot of the rofi window" Set from: Default
! rofi.kb-screenshot:                  Alt+S
! "Toggle case sensitivity" Set from: Default
! rofi.kb-toggle-case-sensitivity:     grave,dead_grave
! "Toggle sort" Set from: Default
! rofi.kb-toggle-sort:                 Alt+grave
! "Quit rofi" Set from: Default
! rofi.kb-cancel:                      Escape,Control+g,Control+bracketleft
! "Custom keybinding 1" Set from: Default
! rofi.kb-custom-1:                    Alt+1
! "Custom keybinding 2" Set from: Default
! rofi.kb-custom-2:                    Alt+2
! "Custom keybinding 3" Set from: Default
! rofi.kb-custom-3:                    Alt+3
! "Custom keybinding 4" Set from: Default
! rofi.kb-custom-4:                    Alt+4
! "Custom Keybinding 5" Set from: Default
! rofi.kb-custom-5:                    Alt+5
! "Custom keybinding 6" Set from: Default
! rofi.kb-custom-6:                    Alt+6
! "Custom Keybinding 7" Set from: Default
! rofi.kb-custom-7:                    Alt+7
! "Custom keybinding 8" Set from: Default
! rofi.kb-custom-8:                    Alt+8
! "Custom keybinding 9" Set from: Default
! rofi.kb-custom-9:                    Alt+9
! "Custom keybinding 10" Set from: Default
! rofi.kb-custom-10:                   Alt+0
! "Custom keybinding 11" Set from: Default
! rofi.kb-custom-11:                   Alt+exclam
! "Custom keybinding 12" Set from: Default
! rofi.kb-custom-12:                   Alt+at
! "Csutom keybinding 13" Set from: Default
! rofi.kb-custom-13:                   Alt+numbersign
! "Custom keybinding 14" Set from: Default
! rofi.kb-custom-14:                   Alt+dollar
! "Custom keybinding 15" Set from: Default
! rofi.kb-custom-15:                   Alt+percent
! "Custom keybinding 16" Set from: Default
! rofi.kb-custom-16:                   Alt+dead_circumflex
! "Custom keybinding 17" Set from: Default
! rofi.kb-custom-17:                   Alt+ampersand
! "Custom keybinding 18" Set from: Default
! rofi.kb-custom-18:                   Alt+asterisk
! "Custom Keybinding 19" Set from: Default
! rofi.kb-custom-19:                   Alt+parenleft

! "The display name of this browser" Set from: Default
! rofi.display-ssh:
! "The display name of this browser" Set from: Default
! rofi.display-run:
! "The display name of this browser" Set from: Default
! rofi.display-drun:
! "The display name of this browser" Set from: Default
! rofi.display-combi:
#+end_src

**** Emacs

Really we set the default colorscheme here so that emacs doesn't blind our eyes we the default black background, but also set some other sane defaults from the default colorscheme so that if emacs does in fact crash, we are in a /dark theme/ environment.

#+begin_src C
Emacs.foreground: xforeground
Emacs.background: xbackground

Emacs.color0:  xcolor0
Emacs.color1:  xcolor1
Emacs.color2:  xcolor2
Emacs.color3:  xcolor3
Emacs.color4:  xcolor4
Emacs.color5:  xcolor5
Emacs.color6:  xcolor6
Emacs.color7:  xcolor7
Emacs.color8:  xcolor8
Emacs.color9:  xcolor9
Emacs.color10: xcolor10
Emacs.color11: xcolor11
Emacs.color12: xcolor12
Emacs.color13: xcolor13
Emacs.color14: xcolor14
Emacs.color15: xcolor15
#+end_src

** Sxhkd - Simple X Hotkey Daemon
:PROPERTIES:
:header-args:shell: :tangle ~/.config/sxhkd/sxhkdrc :mkdirp yes
:END:
*** Terminal Exec Keybindings

This value is specified in =wminit=

#+begin_src shell
# Spawn a normal terminal
super + Return
    $SXHKD_TERMINAL

#+end_src

This actually only works in normal terminals and and not in the emacs vterm. Need to think of another solution to handle that.

#+begin_src shell
# Spawn Terminal matching environment of focused terminal
super + shift + Return
    $HOME/org/config/lib/pwdcfw/$SXHKD_TERMINAL
#+end_src

*** Rofi Dmenu Launcher Keybindings

#+begin_src shell
# Standard $PATH program launcher
super + e
    rofi -show run
#+end_src

#+begin_src shell
# Dmenu for password store
super + p
    $HOME/org/config/lib/rofi/rofi-pass
super + shift + p
    $HOME/org/config/lib/rofi/rofi-pass --qrcode
#+end_src

#+begin_src shell
# Copy a specific bookmark to the clipboard
super + b
    $HOME/org/config/lib/rofi/rofi-book
#+end_src

#+begin_src shell
# Open up a wiki page in read-only mode (originally named notes)
super + n
    $HOME/org/config/lib/rofi/rofi-wiki
super + shift + n
    $HOME/org/config/lib/rofi/rofi-wiki --pdf
#+end_src

#+begin_src shell
# Restore a saved browser session
super + w
    $HOME/org/config/lib/rofi/rofi-browser
#+end_src

#+begin_src shell
# Toggle a display/power profile
super + d
    $HOME/org/config/lib/rofi/rofi-profile
XF86Display
    $HOME/org/config/lib/rofi/rofi-profile
#+end_src

#+begin_src shell
# Control system state (locked, reboot, poweroff, etc.)
#super + Escape
#    $HOME/org/config/lib/rofi/rofi-system LOCK SCREEN
super + ctrl + alt + Escape
    $HOME/org/config/lib/rofi/rofi-system
#+end_src

*** Scrot Keybindings

It's important that these keybindings are prefaces with the =@= token as it implies that the command should be executed on key release as opposed to key press. Scrot and xclip here will not work properly unless they are on key release.

#+begin_src shell
# Interactively select a window or rectangle with the mouse
@Print
    scrot -q 100 -s '/tmp/%F_%T_$wx$h.png' -e 'xclip -selection clipboard -target image/png -i $f'

@shift + Print
    scrot -q 100 '/tmp/%F_%T_$wx$h.png' -e 'xclip -selection clipboard -target image/png -i $f'
#+end_src

*** Media Control Keybindings

#+begin_src shell
XF86MonBrightnessUp
    xbacklight -inc 1 -time 10; \
    $HOME/.config/lemonbar/utils/trigger_fifos bkl

XF86MonBrightnessDown
    xbacklight -dec 1 -time 10; \
    $HOME/.config/lemonbar/utils/trigger_fifos bkl

XF86AudioMute
    pulsemixer --toggle-mute; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioMicMute
    pulsemixer --toggle-mute; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioRaiseVolume
    pulsemixer --change-volume +1; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioLowerVolume
    pulsemixer --change-volume -1; \
    $HOME/.config/lemonbar/utils/trigger_fifos vol

XF86AudioPlay
    $HOME/src/spotify-cli/spotify-cli toggle

XF86AudioNext
    $HOME/src/spotify-cli/spotify-cli next

XF86AudioPrev
    $HOME/src/spotify-cli/spotify-cli prev
#+end_src

** Herbstluftwm Manual Tiling Window Manager
:PROPERTIES:
:header-args:shell: :tangle ~/.config/herbstluftwm/autostart :mkdirp yes :shebang #!/bin/sh
:END:
*** Initial Configuration

Pretty straightforward stuff, setup logger, create a helper function,

#+begin_src shell
. $HOME/org/config/lib/shell/logger
LOGGER=$(get_logger herbstluftwm)
$LOGGER "Initializing herbstluftwm window manager"

hc() {
    herbstclient "$@"
}

hc emit_hook reload
#+end_src

*** WM Custom Rules

Remove any prexisting rules

#+begin_src shell
hc unrule --all
#+end_src

Setup simple focus rules

#+begin_src shell
hc rule focus=on # normally focus new clients
#hc rule focus=off # normally do not focus new clients
#hc rule class=XTerm tag=3 # move all xterms to tag 3
#+end_src

Okay so probably the rules for the terminal are pointless here. Discord one actually doesn't work the way I want it to, but everything else here is pretty important. It makes sure that panels appear where they are suppose to and also ensures that popups are floating.

#+begin_src shell
# give focus to most common terminals
hc rule class~'(.*[Rr]xvt.*|.*[Tt]erm|Konsole)' focus=on
hc rule class~'(Discord|DiscordCanary)' focus=off
hc rule windowtype~'_NET_WM_WINDOW_TYPE_(DIALOG|UTILITY|SPLASH)' pseudotile=on
hc rule windowtype='_NET_WM_WINDOW_TYPE_DIALOG' focus=on
hc rule windowtype~'_NET_WM_WINDOW_TYPE_(NOTIFICATION|DOCK|DESKTOP)' manage=off
#+end_src

*** Source Xorg Universal Settings

We need to configure some X11 specific things that are universally needed regardless of window manager.

#+begin_src shell :noweb yes
# Reapply certain XORG settings by using the wm util startup code block
# ---------------------------------------------------------------------

<<wm-util-startup>>

# ---------------------------------------------------------------------
#+end_src

*** Keybindings

/You can use =xev= to identify X11 keys very easily./

**** Setup

#+begin_src shell
# remove all existing keybinding; Use the super key as the main modifier
hc keyunbind --all
Super=Mod4
#+end_src

**** Reload WM and Close Window

#+begin_src shell
hc keybind $Super-Ctrl-Alt-r reload
hc keybind $Super-q close
#+end_src

**** Window Focus

#+begin_src shell
# focusing clients
hc keybind $Super-Left  focus left
hc keybind $Super-Down  focus down
hc keybind $Super-Up    focus up
hc keybind $Super-Right focus right
hc keybind $Super-h     focus left
hc keybind $Super-j     focus down
hc keybind $Super-k     focus up
hc keybind $Super-l     focus right

# Cycling focus
hc keybind $Super-BackSpace   cycle_monitor
hc keybind $Super-Tab         cycle +1
hc keybind $Super-Shift-Tab   cycle_frame +1
hc keybind $Super-c           cycle_all +1
hc keybind $Super-i jumpto urgent
#+end_src

**** Window Movement

#+begin_src shell
# moving clients
hc keybind $Super-Shift-Left  shift left
hc keybind $Super-Shift-Down  shift down
hc keybind $Super-Shift-Up    shift up
hc keybind $Super-Shift-Right shift right
hc keybind $Super-Shift-h     shift left
hc keybind $Super-Shift-j     shift down
hc keybind $Super-Shift-k     shift up
hc keybind $Super-Shift-l     shift right
#+end_src

**** Splitting Frames

#+begin_src shell
# splitting frames
# create an empty frame at the specified direction
hc keybind $Super-u       split   bottom  0.5
hc keybind $Super-o       split   right   0.5

# let the current frame explode into subframes
hc keybind $Super-Control-space split explode
#+end_src

**** Resizing Frames

#+begin_src shell
# resizing frames
resizestep=0.01

hc keybind $Super-Control-h       resize left +$resizestep
hc keybind $Super-Control-j       resize down +$resizestep
hc keybind $Super-Control-k       resize up +$resizestep
hc keybind $Super-Control-l       resize right +$resizestep
hc keybind $Super-Control-Left    resize left +$resizestep
hc keybind $Super-Control-Down    resize down +$resizestep
hc keybind $Super-Control-Up      resize up +$resizestep
hc keybind $Super-Control-Right   resize right +$resizestep
#+end_src

**** Workspace Definitions (tags)

#+begin_src shell
# tags
tag_names=([1] [2] [3] [4] [5] [6] [7] [8] [9] [0])
tag_keys=( {1..9} 0 )

hc rename default "${tag_names[0]}" || true
for i in ${!tag_names[@]} ; do
    hc add "${tag_names[$i]}"
    key="${tag_keys[$i]}"
    if ! [ -z "$key" ] ; then
        hc keybind "$Super-$key" use_index "$i"
        hc keybind "$Super-Shift-$key" move_index "$i"
    fi
done
#+end_src

**** Workspace Movement

#+begin_src shell
# Jump to previous tag
hc keybind $Super-grave use_previous

# cycle through tags
hc keybind $Super-bracketright use_index +1 --skip-visible
hc keybind $Super-bracketleft  use_index -1 --skip-visible
#+end_src

**** Layout Control

#+begin_src shell
# layouting
hc keybind $Super-r remove
hc keybind $Super-s floating toggle
hc keybind $Super-f fullscreen toggle
hc keybind $Super-t pseudotile toggle

# The following cycles through the available layouts within a frame, but skips
# layouts, if the layout change wouldn't affect the actual window positions.
# I.e. if there are two windows within a frame, the grid layout is skipped.
hc keybind $Super-space                                                       \
            or , and . compare tags.focus.curframe_wcount = 2                 \
                     . cycle_layout +1 vertical horizontal max vertical grid  \
               , cycle_layout +1
#+end_src

**** Mouse Control

#+begin_src shell
# mouse
hc mouseunbind --all
hc mousebind $Super-Button1 move
hc mousebind $Super-Button2 zoom
hc mousebind $Super-Button3 resize
#+end_src

**** Colorscheme Cylcing

#+begin_src shell
# cycle through colorschemes
hc keybind $Super-Ctrl-Alt-bracketright chain , \
        spawn $HOME/org/config/bin/xcolorscheme --next , reload

hc keybind $Super-Ctrl-Alt-bracketleft chain , \
        spawn $HOME/org/config/bin/xcolorscheme --prev , reload
#+end_src

*** Theme Configuration
**** Source Colorscheme

#+begin_src shell
. $HOME/org/config/lib/shell/xrdb_colors
#+end_src

**** Reset Tiling and Floating states

#+begin_src shell
hc attr theme.tiling.reset 1
hc attr theme.floating.reset 1
#+end_src

**** Frame Appearance

#+begin_src shell
hc set frame_transparent_width 1
hc set frame_border_width 1
hc set frame_border_active_color $XBACKGROUND
hc set frame_border_normal_color $XBACKGROUND

hc set frame_bg_transparent 1
hc set frame_bg_normal_color $XBACKGROUND
hc set frame_bg_active_color $XCOLOR8

hc set always_show_frame 0
hc set frame_gap 8
hc set frame_padding 0
#+end_src

**** Window Appearance

#+begin_src shell
hc attr theme.active.outer_color $XBACKGROUND
hc attr theme.active.inner_color $XBACKGROUND

hc attr theme.normal.color $BLACK
hc attr theme.active.color $WHITE
hc attr theme.urgent.color orange

hc attr theme.border_width 9
hc attr theme.inner_width 3
hc attr theme.outer_width 4

hc attr theme.inner_color $XBACKGROUND
hc attr theme.outer_color $XBACKGROUND

hc attr theme.floating.border_width 9
hc attr theme.floating.inner_width 3
hc attr theme.floating.outer_width 4

hc attr theme.floating.outer_color $XBACKGROUND
hc attr theme.background_color '#141414'

hc set window_gap 0
hc set smart_window_surroundings 0
hc set smart_frame_surroundings 1
hc set mouse_recenter_gap 0
#+end_src

**** Tree View

#+begin_src shell
hc set tree_style 'â¾â âââ¼ââ'
#+end_src

**** Montior Setup

Well monitor setup doesn't belong here really, but we're doing it here because we need to make space for the panels.

#+begin_src shell
# unlock, just to be sure
hc unlock
hc detect_monitors
#+end_src

**** Configure Panel Height

#+begin_src shell
PANEL_HEIGHT=20
for monitor in $(seq 0 2); do
    hc pad $monitor $PANEL_HEIGHT 0 $PANEL_HEIGHT 0
done
#+end_src

*** Event Hooks

This starts a couple FIFO hooks so that lemonbar can update the information on it's panel as effeciently as possible.

**** Event Hooks Startup Verification

#+begin_src shell
if [ $(pgrep -cx herbstclient) -gt 0 ]; then
    printf "The herbstluftwm event hooks for lemonbar are already running.\n" >&2
    $LOGGER "The herbstluftwm event hooks for lemonbar are already running."
    exit 1
fi
#+end_src

**** Event Hooks Trigger Definition

#+begin_src shell
WSP_TRIGGER="$HOME/.config/lemonbar/utils/trigger_fifos wsp"
WIN_TRIGGER="$HOME/.config/lemonbar/utils/trigger_fifos win"
WARG="'(focus_changed|window_title|panel_init)'"
#+end_src

**** Initialize Event Hooks

I don't remember why I commented one of the hooks out, oh thats rights, its because I'm not using the lemonbar xwindow module I made anymore.

#+begin_src shell
(herbstclient --idle       | while read -r line; do $WSP_TRIGGER; done) &
#(herbstclient --idle $WARG | while read -r line; do $WIN_TRIGGER; done) &

$LOGGER "All hook have been started"
#+end_src

** Lemonbar Panel
*** Panel Launcher
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/lemonbar :mkdirp yes :shebang #!/bin/sh
:END:

Load config and logger.

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar)
#+end_src

Prevent multiple panels from starting up (really bad).

#+begin_src shell
if [ $(pgrep -cx lemonbar) -gt 1 ]; then
    $LOGGER -s "The panel is already running"
    exit 1
fi
$LOGGER "Starting lemonbar init script"
#+end_src

Using =trap=, we can change the behaviour of our shell script.

#+begin_src shell
trap 'trap - TERM; kill 0' INT TERM QUIT EXIT
#+end_src

Now it's time to make each of the panel FIFOs and start the modules.

#+begin_src shell
# Prepare the FIFOS
$HOME/.config/lemonbar/utils/make_fifos

# Tail command to ensure that fifos never close
TAIL="tail --lines=+1 --follow"

# Add modules to the top fifo
$LOGGER "Setting up top fifo modules"
$HOME/.config/lemonbar/modules/date         > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/network      > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/time         > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/whoami       > $PANEL_TOP_FIFO &
$HOME/.config/lemonbar/modules/battery      > $PANEL_TOP_FIFO &
$TAIL $EVENT_BKL_FIFO \
    | $HOME/.config/lemonbar/modules/backlight > $PANEL_TOP_FIFO &

# Add modules to the bot fifo
$LOGGER "Setting up bot fifo modules"
$HOME/.config/lemonbar/modules/cpu          > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/filesystems  > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/memory       > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/spotify      > $PANEL_BOT_FIFO &
$HOME/.config/lemonbar/modules/volume_const > $PANEL_BOT_FIFO &
# $HOME/etc/lemonbar/modules/windowinfo   < $EVENT_WIN_FIFO > $PANEL_BOT_FIFO &
$TAIL $EVENT_WSP_FIFO \
    | $HOME/.config/lemonbar/modules/workspaces   > $PANEL_BOT_FIFO &
$TAIL $EVENT_VOL_FIFO \
    | $HOME/.config/lemonbar/modules/volume_event > $PANEL_BOT_FIFO &
#+end_src

Setup the argument string to pass send to lemonbar. Uncomment fonts as needed.

#+begin_src shell
# Define lemonbar opts
# -f dina:size=12
# -f xos4Terminus:style=Bold:size=12
# -f IosevkaTerm:size=12
# -f PowerlineSymbols:style=Medium:size=12
# -f -wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1
OPTS="-g x20
-F ${XBACKGROUND}
-B ${XBACKGROUND}
-f IosevkaTerm:size=12
-f FontAwesome5Free:style=Regular:size=14
-f FontAwesome5Free:style=Solid:size=14
-f FontAwesome5Brands:style=Regular:size=14
-u 3"

$LOGGER "Lemonbar defined with the following opts : $OPTS"
#+end_src

Actually launch our panel loops (while reading from the fifos) and pipe them into lemonbar. We should also pipe the output from lemonbar to a shell process in-case there are modules that want to run specific commands.

#+begin_src shell
# Start the top panel
$LOGGER "Initializing lemonbar using top fifo"
$HOME/.config/lemonbar/utils/loop TOP < $PANEL_TOP_FIFO | lemonbar $OPTS | sh &

# Start the bottom panel
$LOGGER "Initializing lemonbar using bot fifo"
$HOME/.config/lemonbar/utils/loop BOT < $PANEL_BOT_FIFO | lemonbar $OPTS -b | sh &

$LOGGER "Lemonbar finished."
wait
#+end_src

*** Default Configuration
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/config.default :mkdirp yes
:END:

The default configuration is our source for all variables and functions that lemonbar and its modules will need to use. So we also source our utils files and other lib files here.

#+begin_src shell
# Import modules needed but anything that imports this config
. $HOME/org/config/lib/shell/logger
. $HOME/org/config/lib/shell/xrdb_colors
. $HOME/.config/lemonbar/utils/wrappers
. $HOME/.config/lemonbar/utils/multi_monitor_support
. $HOME/.config/lemonbar/utils/where_fifos

# Source local system config in case there are system specific changes
. $HOME/.config/lemonbar/config
#+end_src

Choose the icon wrapper.

#+begin_src shell
# Choose the output wrapper
MSG_WRAPPER=icon_wrapper
#+end_src

Anchors are an important concept with regards to FIFOs. They inform the main loop which module wrote which string.

#+begin_src shell
# Specify the Anchor Character for each module
ANCHOR_BACKLIGHT='L'
ANCHOR_BATTERY='B'
ANCHOR_CPU='C'
ANCHOR_DATE='D'
ANCHOR_FILESYSTEMS='F'
ANCHOR_MEMORY='M'
ANCHOR_NETWORK='N'
ANCHOR_SWAP='S'
ANCHOR_SPOTIFY='J'
ANCHOR_TIME='T'
ANCHOR_WHOAMI='U'
ANCHOR_WININFO='X'
ANCHOR_WORKSPACES='W'
ANCHOR_VOLUME='V'
#+end_src

Setup various refresh timings for various modules

#+begin_src shell
REFRESH_BATTERY=2
REFRESH_CPU=3
REFRESH_DATE=86400
REFRESH_FILESYSTEMS=10
REFRESH_MEMORY=3
REFRESH_NETWORK=2
REFRESH_SWAP=3
REFRESH_TIME=1
REFRESH_VOLUME=2
#+end_src

I played around with fonts in lemonbar, but honestly I'm not really a fan. If I want to enable it at any point, just need to set =LEMONBAR_ENABLE_ICONS= in the local config to be a non-empty string. But this aren't actually used *EVER* in the modules anymore as I'm using powerline icons now. I /should/ probably delete this and remove this segment of code.

#+begin_src shell
# Font Awesome icons for various modules
# https://fontawesome.com/icons?d=gallery&m=free
if [ -n "$LEMONBAR_ENABLE_ICONS" ]; then
    ICON_BACKLIGHT=$(env printf "\uf042 ")
    ICON_BATTERY_AC=$(env printf "\uf1e6 ")
    ICON_BATTERY_EMPTY=$(env printf "\uf244 ")
    ICON_BATTERY_NEAR_EMPTY=$(env printf "\uf243 ")
    ICON_BATTERY_HALF=$(env printf "\uf242 ")
    ICON_BATTERY_NEAR_FULL=$(env printf "\uf241 ")
    ICON_BATTERY_FULL=$(env printf "\uf240 ")
    ICON_BATTYER_CHARGING=$ICON_BATTERY_AC
    ICON_CPU=$(env printf "\uf24d ")
    ICON_DATE=$(env printf "\uf073 ")
    ICON_FILESYSTEMS=$(env printf "\uf0a0 ")
    ICON_MEMORY=$(env printf "\uf538 ")
    ICON_MUSIC=$(env printf "\uf001 ")
    ICON_NETWORK_ETHERNET=$(env printf "\uf796 ")
    ICON_NETWORK_OFFLINE=$(env printf "\uef6ff ")
    ICON_NETWORK_WIFI=$(env printf "\uf1eb ")
    ICON_SWAP=$(env printf "\uf1c0 ")
    ICON_TIME=$(env printf "\uf017 ")
    ICON_WHOAMI=$(env printf "\uf007 ")
    ICON_LINUX=$(env printf "\uf120 ")
    ICON_WORKSPACES=$(env printf "\uf108 ")
    ICON_VOLUME=$(env printf "\uf025 ")
else
    # Some icons are better left as blank so not all are defined
    ICON_BACKLIGHT="bL: "
    ICON_BATTERY_EMPTY="bat: "
    ICON_BATTERY_NEAR_EMPTY=$ICON_BATTERY_EMPTY
    ICON_BATTERY_HALF=$ICON_BATTERY_EMPTY
    ICON_BATTERY_NEAR_FULL=$ICON_BATTERY_EMPTY
    ICON_BATTERY_FULL=$ICON_BATTERY_EMPTY
    ICON_BATTERY_CHARGING="a/c: "
    ICON_CPU="cpu: "
    ICON_MEMORY="mem: "
    ICON_SWAP="swap: "
    ICON_VOLUME="vol: "
fi
#+end_src

There define the powerline icons (to use these, the module strings have to specially confiugred to use them).

#+begin_src shell
# Powerline Icons
PL_R=$(env printf "\ue0b0")
PL_Rb=$(env printf "\ue0b1")
PL_L=$(env printf "\ue0b2")
PL_Lb=$(env printf "\ue0b3")
#+end_src

Setup network interfaces and filesystem paths. These are dummy values and should be overriden with the locally generated config.

#+begin_src shell
# Hardware Specification (override this values in local config)
WIFI_INTERFACE=${WIFI_INTERFACE:-"wlan0"}
ETHERNET_INTERFACE=${ETHERNET_INTERFACE:-"eth0"}
FILESYSTEMS=${FILESYSTEMS:-"/dev/sda4"}
#+end_src

*** Utilities
**** Main Loop
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/loop :mkdirp yes :shebang #!/bin/sh
:END:

Source the main config, setup the loggers and figure out which mode this loop belows to (=TOP= or =BOTTOM=).

#+begin_src shell
. $HOME/.config/lemonbar/config.default
MODE="$1"
LOGGER=$(get_logger "lemonbar.loop.$MODE")

$LOGGER "Configuring the $MODE loop"
#+end_src

This setup below is pretty confusing but it was done because I have two different monitor setups. A triple monitor setup and standalone laptop mode. Depending on the mode we were in, the panel output should be split over three monitors or all should appear on the same one. The variables below simply help in using the same looping function instead of rewriting a different one for each monitor setup. Refer to the lemonbar documentation to understand how monitor specification works.

#+begin_src shell
# Define the monitors
$LOGGER "Checking for multi monitor support"
if [ -f $TRIPLE_MONITOR_TOGGLE ]; then

    MONITOR_1="%{S0}"
    MONITOR_2="%{S1}"
    MONITOR_3="%{S2}"

    M1L="%{l}" M1C="%{c}" M1R="%{r}"
    M2L="%{l}" M2C="%{c}" M2R="%{r}"
    M3L="%{l}" M3C="%{c}" M3R="%{r}"

else

    MONITOR_1="%{S0}%{l}"
    MONITOR_2="%{S0}%{c}"
    MONITOR_3="%{S0}%{r}"

    M1L="" M1C="" M1R=""
    M2L="" M2C="" M2R=""
    M3L="" M3C="" M3R=""

fi
#+end_src

Below is the main loop for lemonbar. It uses the anchors we defined in the config to capture each modules output into module specific variables. We can then print it out to the top and bottom FIFOs.

#+begin_src shell
$LOGGER "Initializing loop to construct lemonbar output"
while read -r line; do
    # echo "Current line: $line" >&2
    case $line in
        $ANCHOR_BACKLIGHT*)     bkl="${line#?}" ;;
        $ANCHOR_BATTERY*)       bat="${line#?}" ;;
        $ANCHOR_CPU*)           cpu="${line#?}" ;;
        $ANCHOR_DATE*)          cal="${line#?}" ;;
        $ANCHOR_FILESYSTEMS*)   fsf="${line#?}" ;;
        $ANCHOR_MEMORY*)        mem="${line#?}" ;;
        $ANCHOR_NETWORK*)       net="${line#?}" ;;
        $ANCHOR_SPOTIFY*)       mus="${line#?}" ;;
        $ANCHOR_TIME*)          clk="${line#?}" ;;
        $ANCHOR_WHOAMI*)        usr="${line#?}" ;;
        $ANCHOR_WININFO*)       win="${line#?}" ;;
        $ANCHOR_WORKSPACES*)    wsp="${line#?}" ;;
        $ANCHOR_VOLUME*)        vol="${line#?}" ;;
    esac

    # Print the contents of our modules based on the mode
    if [ "$MODE" = "TOP" ]; then
        m1="${MONITOR_1}${M1L}${M1C}$usr${M1R}"
        m2="${MONITOR_2}${M2L}${M2C}$cal$clk${M2R}"
        m3="${MONITOR_3}${M3L}$bkl${M3C}$net${M3R}$bat"
        printf "%s\n" "$m1$m2$m3"

    elif [ "$MODE" = "BOT" ]; then
        m1="${MONITOR_1}${M1L}$vol$mus${M1C}${M1R}"
        m2="${MONITOR_2}${M2L}${M2C}$win$wsp${M2R}"
        m3="${MONITOR_3}${M3L}$fsf$mem${M3C}${M3R}$cpu"
        printf "%s\n" "$m1$m2$m3"

    else
        printf "Panel loop given incorrect mode!\n" >&2
    fi
done
#+end_src

**** Make FIFOs
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/make_fifos :mkdirp yes :shebang #!/bin/sh
:END:

We use a seperate script to make the FIFOs so that other processes can start buffering without having to wait for lemonbar to finish starting. *Therefore*, this needs to be called before spawning lemonbar.

Like with all other lemonbar components, setup the logger and get the necessary variables

#+begin_src shell
. $HOME/org/config/lib/shell/logger
. $HOME/.config/lemonbar/utils/where_fifos
LOGGER=$(get_logger lemonbar.make_fifos)
#+end_src

Initialize the actualy panel FIFOs. This is what lemonbar will actually end up reading after all the module output is formatted properly.

#+begin_src shell
$LOGGER "Initializing panel fifo files"
[ -e "$PANEL_TOP_FIFO" ] && rm $PANEL_TOP_FIFO
[ -e "$PANEL_BOT_FIFO" ] && rm $PANEL_BOT_FIFO
mkfifo $PANEL_TOP_FIFO
mkfifo $PANEL_BOT_FIFO
#+end_src

In order to make lemonbar as computationally effecient as possible, we also make use of FIFOs that are used in conjunction with event hooks from external sources. This enables us to update specific modules without the use of the =sleep= command. /Also note to self, there isn't a need to make the =$EVENT_WIN_FIFO= as the module that will use is disabled.../

#+begin_src shell
$LOGGER "Initializing event fifos"
[ -e "$EVENT_BKL_FIFO" ] && rm $EVENT_BKL_FIFO
[ -e "$EVENT_VOL_FIFO" ] && rm $EVENT_VOL_FIFO
[ -e "$EVENT_WSP_FIFO" ] && rm $EVENT_WSP_FIFO
[ -e "$EVENT_WIN_FIFO" ] && rm $EVENT_WIN_FIFO
mkfifo $EVENT_BKL_FIFO
mkfifo $EVENT_VOL_FIFO
mkfifo $EVENT_WSP_FIFO
mkfifo $EVENT_WIN_FIFO
#+end_src

Finally, we need to initialize these FIFOs. I'm pretty confident this has to happen because I was dealing with some issues where the FIFOs would close and lemonbar wasn't able to read their output anymore.

#+begin_src shell
$LOGGER "Starting init writers for event fifos"
echo "backlight fifo init" > $EVENT_BKL_FIFO &
echo "workspace fifo init" > $EVENT_WSP_FIFO &
# echo "window fifo init"    > $EVENT_WIN_FIFO &
echo "volume fifo init"    > $EVENT_VOL_FIFO &
#+end_src

**** Trigger FIFOs
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/trigger_fifos :mkdirp yes :shebang #!/bin/sh
:END:

We use a sepeate script to send signals to the fifos that an event has occured since we don't want oother processes to really know the locations of these fifos in case they change. It also just serves to create a simpler interface lol.

We don't need the config here but we do need to source the locations.

#+begin_src shell
. $HOME/.config/lemonbar/utils/where_fifos
#+end_src

Basically, depending the argument, we send a signal to a specific FIFO. Here are the accepted signals (=bkl=, =wsp=, =win=, =vol=).

#+begin_src shell
TRIGGER_FIFO=$1

if [ $TRIGGER_FIFO = "bkl" ]; then
    echo "." > $EVENT_BKL_FIFO
elif [ $TRIGGER_FIFO = "wsp" ]; then
    echo "." > $EVENT_WSP_FIFO
elif [ $TRIGGER_FIFO = "win" ]; then
    echo "." > $EVENT_WSP_FIFO
elif [ $TRIGGER_FIFO = "vol" ]; then
    echo "." > $EVENT_VOL_FIFO
fi
#+end_src

**** Where FIFOs
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/where_fifos :mkdirp yes
:END:

Not much to be said here. This is just a seperate config file that keeps track of where we make the FIFOs in case I decide to change them.

#+begin_src shell
# Primary FIFOs
PANEL_TOP_FIFO=/tmp/.lemonbar.panel_top.fifo
PANEL_BOT_FIFO=/tmp/.lemonbar.panel_bot.fifo

# Event FIFOs
EVENT_BKL_FIFO=/tmp/.lemonbar.backlight_event.fifo
EVENT_VOL_FIFO=/tmp/.lemonbar.volume_event.fifo
EVENT_WSP_FIFO=/tmp/.lemonbar.workspace_event.fifo
EVENT_WIN_FIFO=/tmp/.lemonbar.wininfo_event.fifo
#+end_src

**** Output Wrappers
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/wrappers :mkdirp yes
:END:

Wrappers are basically used by the modules so that we don't have to rewrite output code code for each module. *Ironically* I ended up doing that anyway since I decide to setup a powerline look for them. In any case, there are still here in case I want to use them in the future. And maybe, it might be possible to setup a more complicated wrapper that supports powerline icons.

The minimal wrapper just displays text in square brackets for each module and its also colored as well.

#+begin_src shell
# Minimal wrapper
legacy_wrapper() {
    icon=$1 && shift && color=$1 && shift && msg=$@
    printf "[$icon %{F$color}$msg%{F-}]"
}
#+end_src

The icon wrapper on the other hand is meant for displaying the module with a font icon (this is configured through the global config file) and the default icons are the SIJI icon pack.

#+begin_src shell
# Use siji fonts or some other unicode fonts
icon_wrapper() {
    icon=$1 && shift && color=$1 && shift && msg=$@
    printf " $icon %%{F$color}$msg%%{F-} "
}
#+end_src

The debug wrapper is primarily used when debugging a module since all the formatting can sometimes make it hard to tell what the panel is really outputting.

#+begin_src shell
# debug wrapper for testing
debug_wrapper() {
    icon=$1 && shift && color=$1 && shift && msg=$@
    echo -ne "[DEBUG $icon $color $msg]"
}
#+end_src

**** Multi-Monitor Support
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/utils/multi_monitor_support :mkdirp yes
:END:

This might be pointless to keep as a seperate script but as (not anymore) was another script that needed the location of where to trigger the monitor toggle (whether I am in a multi monitor environment or not), this was necessary. Keep it setup for backwards compatibility.

#+begin_src shell
# Triple Monitor Toggle File
TRIPLE_MONITOR_TOGGLE=$HOME/.config/lemonbar/enable_triple_monitor
#+end_src

*** Modules
**** Backlight
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/backlight :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.backlight)

$LOGGER "Initializing backlight module"

while read -r backlight_event; do
    msg="$(xbacklight -get | sed -e 's/\.[0-9]*//g')"
    if [ -z "$msg" ]; then
        echo "$ANCHOR_BACKLIGHT%{F$BLACK}${PL_L}%{F-}"
    else
        msg="$msg%"
        msg="%{B$BLACK}%{F$WHITE} ${ICON_BACKLIGHT}$msg %{F-}%{B-}"
        msg="%{F$BLACK}${PL_L}%{F-}$msg"
        msg="$msg%{B$BLACK}%{F$GREEN}${PL_Lb}%{F-}%{B-}"
        echo "$ANCHOR_BACKLIGHT$msg"
    fi
done
#+end_src

**** Battery
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/battery :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.battery)

$LOGGER "Initializing battery module"

# TODO: Dynamically set this based on status
bg_color=$GREEN
fg_color=$XBACKGROUND
oscillator=0
refresh_rate=$REFRESH_BATTERY

while true; do
    batloc="/sys/class/power_supply/"
    batlist=$(ls $batloc | grep "BAT")
    out=""
    icon=""

    if [ -n "${batlist}" ]; then
        for bat in $batlist; do
            cap="$(cat ${batloc}${bat}/capacity)"
            stat="$(cat ${batloc}${bat}/status)"
            batid=$(echo $bat | tr -d 'BAT')

            # Uncomment this if I use a laptop with more than 1 battery again
            #out="${out} ${batid}:${cap}%"
            out="${out}${cap}%"

            if [ $cap -lt 15 ] && [ $stat = "Discharging" ]; then
                refresh_rate="0.2"
                icon=$ICON_BATTERY_EMPTY
                if [ $oscillator -eq 0 ]; then
                    bg_color=$RED
                    fg_color=$XBACKGROUND
                    oscillator=1
                else
                    fg_color=$RED
                    bg_color=$XBACKGROUND
                    oscillator=0
                fi
            else
                bg_color=$GREEN
                fg_color=$XBACKGROUND
                oscillator=0
                refresh_rate=$REFRESH_BATTERY
                icon=$ICON_BATTERY_FULL
            fi

        done
    else
        icon=$ICON_BATTERY_AC
        out="${out}A/C"
    fi

    msg="%{B$bg_color}%{F$fg_color} ${icon}$out %{F-}%{B-}"
    msg="%{F$bg_color}%{B$BLACK}${PL_L}%{B-}%{F-}$msg"

    echo "$ANCHOR_BATTERY$msg"
    sleep $refresh_rate
done
#+end_src

**** CPU
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/cpu :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.cpu)

$LOGGER "Initializing cpu module"

while true; do
    msg=$(cat /proc/loadavg | awk '{print $1}')

    # TODO: Dynamically set this based on cpu load
    color=$MAGENTA

    msg="%{B$color} ${ICON_CPU}$msg %{B-}"
    msg="%{F$color}%{B$BLACK}${PL_L}%{B-}%{F-}$msg"

    echo "$ANCHOR_CPU$msg"
    sleep $REFRESH_CPU
done
#+end_src

**** Date
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/date :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.date)

$LOGGER "Initializing date module"

# Set the refresh time to how many seconds till midnight
REFRESH_DATE=$(($(date -d 23:59:59 +%s) - $(date +%s) + 1))

while true; do
    #msg="%{F$GREEN}$(date +'%A, %d %B %Y')%{F-}"
    msg="%{B$BLACK}%{F$CYAN} ${ICON_DATE}$(date +'%a %Y/%m/%d')"
    msg="%{F$BLACK}${PL_L}%{F-}$msg "
    echo "$ANCHOR_DATE$msg"
    sleep $REFRESH_DATE
    REFRESH_DATE=86400 # Update the seconds to total seconds in a day
done
#+end_src

**** Filesystems
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/filesystems :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.filesystems)

$LOGGER "Initializing filesystems module"

while true; do

    msg=""
    for FS in $FILESYSTEMS; do
        fs_info=$(df | grep $FS)
        if [ -n "$fs_info" ]; then
            fs_path=$(echo $fs_info | awk '{print $6}' | sed -e 's|/home/zamlz|~|g')
            fs_used=$(echo $fs_info | awk '{print $5}')
            msg="$msg $fs_path:$fs_used"
        fi
    done

    msg="%{B$BLACK}%{F$WHITE} ${ICON_FILESYSTEMS}$msg %{F-}%{B-}"
    msg="%{F$BLACK}${PL_L}%{F-}$msg"

    echo "$ANCHOR_FILESYSTEMS$msg"
    sleep $REFRESH_FILESYSTEMS
done
#+end_src

**** Memory
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/memory :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.memory)

$LOGGER "Initializing memory module"

while true; do
    memory=$(free -h | grep 'Mem:')
    memory_total=$(echo $memory | awk {'print $2'} | tr -d ' ')
    memory_used=$(echo $memory | awk {'print $3'} | tr -d ' ')
    mem_msg="$memory_used/$memory_total"

    # TODO: Set this dynamically based on used mem
    mem_color=$MAGENTA

    swap=$(free -h | grep 'Swap:')
    swap_total=$(echo $swap | awk {'print $2'} | tr -d ' ')
    swap_used=$(echo $swap | awk {'print $3'} | tr -d ' ')
    swap_msg="$swap_used/$swap_total"

    # TODO: Set this dynamically based on used mem
    swap_color=$MAGENTA

    msg="%{B$BLACK}%{F$MAGENTA}${PL_Lb}%{F-}"
    msg="$msg%{F$mem_color} ${ICON_MEMORY}$mem_msg %{F-}"
    msg="$msg%{F$MAGENTA}${PL_Lb}%{F-}"
    msg="$msg%{F$swap_color} ${ICON_SWAP}$swap_msg %{F-}%{B-}"

    echo "$ANCHOR_MEMORY$msg"
    sleep $REFRESH_MEMORY
done
#+end_src

**** Network
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/network :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.network)

$LOGGER "Initializing network module"

# State file for identifying if lemonbar displays ip address or not
ip_toggle="/tmp/.ip_toggle"

while true; do

    wifi_status=$(ip -br addr | grep $WIFI_INTERFACE)
    ethernet_status=$(ip -br addr | grep $ETHERNET_INTERFACE)

    interface=""
    primary_msg=""
    icon=""

    # Check if wifi is online
    if [ "$(echo $wifi_status | awk '{print $2}')" = "UP" ]; then

        ssid=$(iw $WIFI_INTERFACE link \
            | grep 'SSID:' \
            | sed -E "s/.*SSID:(.*)/\\1/")

        signal=$(iw $WIFI_INTERFACE link \
            | grep 'signal' \
            | awk '{print $2}')

        interface=$WIFI_INTERFACE
        primary_msg="$ssid ($signal dBm)"
        ip_addr=$(echo $wifi_status | awk '{print $3}')
        icon=$ICON_NETWORK_WIFI

    # Check if ethernet is online
    elif [ "$(echo $ethernet_status | awk '{print $2}')" = "UP" ]; then
        interface=$ETHERNET_INTERFACE
        primary_msg="Ethernet"
        ip_addr=$(echo $ethernet_status | awk '{print $3}')
        icon=$ICON_NETWORK_ETHERNET

    # State we are offline
    else
        interface="localhost"
        primary_msg="OFFLINE"
        ip_addr="127.0.0.1/8"
        icon=$ICON_NETWORK_OFFLINE
    fi

    # If the ip toggle file exists, print the ip address
    if [ -f "$ip_toggle" ]; then
        msg="%{A:rm $ip_toggle:}${icon}$interface: $ip_addr%{A}"
    else
        msg="%{A:touch $ip_toggle:}${icon}$interface: $primary_msg%{A}"
    fi

    msg="%{B$BLACK}%{F$GREEN} $msg %{F-}%{B-}"
    echo "$ANCHOR_NETWORK$msg"
    sleep $REFRESH_NETWORK
done
#+end_src

**** Spotify
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/spotify :mkdirp yes :shebang #!/bin/sh
:END:

This makes use of =spotify-cli=, a simple script I wrote that interfaces with spotify's dbus.

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.spotify)

$LOGGER "Initializing spotify module"

# Colors are actually set in date!!!!
while true; do
    # This repo should be cloned or installed
    metadata=$($HOME/src/spotify-cli/spotify-cli)

    if [ -z "$(echo $metadata | grep 'ERROR')"]; then

        # Notice how the first message doesn't have a foreground color open
        # statement but has a close statement. This is because we are capturing
        # the color change from the [volume] module.
        msg="%{B$BLACK}${PL_R}%{B-}%{F-}"

        # Gather info from the spotify cli script
        title=$(echo $metadata | sed -e 's/title: \(.*\) artist:.*/ \1 /')
        artist=$(echo $metadata | sed -e 's/.*artist: \(.*\) album:.*/\1/')
        paused=$(echo $metadata | sed -e 's/.*status: \(.*\)/\1/')

        artist=" ${ICON_MUSIC}${artist} "
        if [ "$paused" != "Paused" ]; then
            status_color=$WHITE
        else
            status_color=$XBACKGROUND
        fi

        msg="$msg%{B$BLACK}%{F$CYAN}$artist"
        msg="$msg${PL_Rb}%{F-}%{F$status_color}"
        msg="$msg$title%{B-}%{F$BLACK}${PL_R}%{F-}"
    else

        # IMPORTANT: look at comment above
        msg="%{B$XBACKGROUND}${PL_R}%{B-}%{F-}"
    fi

    echo "$ANCHOR_SPOTIFY$msg"
    sleep $REFRESH_TIME
done
#+end_src

**** Time
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/time :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.time)

$LOGGER "Initializing time module"

# Colors are actually set in date!!!!
while true; do
    msg="$(date +'%l:%M:%S %p') %{F-}%{B-}"
    msg="  %{F$CYAN}${ICON_TIME}$msg%{F$BLACK}${PL_R}%{F-}"
    echo "$ANCHOR_TIME$msg"
    sleep $REFRESH_TIME
done
#+end_src

**** Who am I
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/whoami :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.whoami)

$LOGGER "Initializing whoami module"

wmsg="${ICON_WHOAMI}$(whoami)@$(hostname)"

version=$(uname -r | sed -e 's/-.*//g')
distro=$(grep ^ID= /etc/os-release | sed -e 's/^ID=//g' | tr -d '"')
distro=$(echo $distro | sed 's/.*/\u&/')
umsg="${ICON_LINUX}$distro $(uname -o) $version $(uname -m)"

prm_color='#256568'
alt_color=$BLACK

msg="%{B$prm_color} $wmsg %{B-}"
msg="$msg%{F$prm_color}%{B$alt_color}${PL_R}%{F-}"
msg="$msg %{F$prm_color}$umsg%{F-} %{B-}"
msg="$msg%{F$alt_color}${PL_R}%{F-}"

echo "$ANCHOR_WHOAMI$msg"
#+end_src

**** Volume
:PROPERTIES:
:header-args:shell: :mkdirp yes :shebang #!/bin/sh
:END:

The volume module is a bit different from the other modules so far. We need to update it whenever we trigger a volume change (this is done by capturing the volume events via the media keys. Herbstluftwm will then pass a message to the volume event FIFO). However this is not enough as the volume can be changed by the software as well. So ontop of this, we also have a periodic update as well.

/Here is the primary update logic:/

#+NAME: LEMONBAR_VOLUME_UPDATE_OP
#+begin_src shell
# LEMONBAR_VOLUME_UPDATE_OP
if [ $(pulsemixer --get-mute) -eq 0 ]; then
    msg="$(pulsemixer --get-volume | awk '{print $1}')%"
    color=$CYAN
else
    msg="MUTE"
    color=$RED
fi
msg="%{B$color} ${ICON_VOLUME}$msg %{B-}%{F$color}"
echo "$ANCHOR_VOLUME$msg"
#+end_src

/Where is the periodic version of the volume module:/

#+begin_src shell :noweb yes :tangle ~/.config/lemonbar/modules/volume_const
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.volume.const)

$LOGGER "Initializing volume module [constant]"

while true; do
    <<LEMONBAR_VOLUME_UPDATE_OP>>
    sleep $REFRESH_VOLUME
done
#+end_src

/Here is the event triggered version of the volume module:/

#+begin_src shell :noweb yes :tangle ~/.config/lemonbar/modules/volume_event
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.volume.event)

$LOGGER "Initializing volume module [event driven]"

while read -r volume_event; do
    (
        <<LEMONBAR_VOLUME_UPDATE_OP>>
    ) &
done
#+end_src

**** Window Info
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/windowinfo :mkdirp yes :shebang #!/bin/sh
:END:

I don't actually use this module anymore, but its here in case I ever do again.

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.windowinfo)

$LOGGER "Initializing windowinfo module"

while read -r window_event; do
    win_active=$(xdotool getactivewindow)
    win_class=$(xprop -id $win_active \
        | grep WM_CLASS \
        | awk '{print $NF}' \
        | tr -d '"' )

    if [ -z "$win_class" ]; then
        msg="<$(xprop -root _NET_WM_NAME \
            | cut -d " " -f3- \
            | tr -d '"')>"
    else
        msg="$win_class ($win_active)"
    fi
    msg=$($MSG_WRAPPER $ICON_WININFO $BLUE $msg)
    echo "$ANCHOR_WININFO$msg"
    sleep $REFRESH_WININFO
done
#+end_src

**** Workspaces
:PROPERTIES:
:header-args:shell: :tangle ~/.config/lemonbar/modules/workspaces :mkdirp yes :shebang #!/bin/sh
:END:

#+begin_src shell
. $HOME/.config/lemonbar/config.default
LOGGER=$(get_logger lemonbar.workspaces)

$LOGGER "Initializing workspaces module [herbstluftwm]"

hclm() {
    herbstclient list_monitors
}

while read -r workspace_event; do
    # For whatever happens here so we can speed up the updates even further
    # commented for now, but uncomment to make it faster
    (

    # convert the current space id to index-1 format
    current_space_id=$(xprop -root _NET_CURRENT_DESKTOP \
        | awk '{print $3}')
    total_spaces=$(xprop -root _NET_NUMBER_OF_DESKTOPS \
        | awk '{print $3}')
    all_space_names=$(xprop -root _NET_DESKTOP_NAMES \
        | cut -d " " -f3- \
        | tr -d ',"')
    active_windows=$(xprop -root _NET_CLIENT_LIST \
        | cut -d " " -f5- \
        | tr -d ',')
    active_spaces=$(for window in $active_windows; do \
        xprop -id $window _NET_WM_DESKTOP \
        | cut -d " " -f3- ; done)
    msg=""

    # Is there to get this info without relying on herbs?
    mon_1=$(hclm | grep '0:' | awk '{print $5}' | tr -d '"')
    mon_2=$(hclm | grep '1:' | awk '{print $5}' | tr -d '"')
    mon_3=$(hclm | grep '2:' | awk '{print $5}' | tr -d '"')

    for space_id in $(seq $total_spaces); do

        # Get the actual name of the workspace
        ws=$(echo $all_space_names | awk -v N=$space_id '{print $N}')
        # Fix the index of the space_id to be zero index
        # (note, awk needs to be in index 1 format)
        space_id=$((space_id - 1))

        # check if the workspace is empty
        if [ "$ws" = "$mon_1" ]; then
            ws="%{F$RED}$ws%{F-}"
        elif [ "$ws" = "$mon_2" ]; then
            ws="%{F$GREEN}$ws%{F-}"
        elif [ "$ws" = "$mon_3" ]; then
            ws="%{F$BLUE}$ws%{F-}"
        elif [ -z "$(echo $active_spaces | grep $space_id)" ]; then
            ws="%{F$XBACKGROUND}$ws%{F-}"
        else
            ws="%{F#585858}$ws%{F-}"
        fi

        # mark output if currently focused
        if [ $space_id -eq $current_space_id ]; then
            msg="$msg %{+u}$ws%{-u}"
        else
            msg="$msg $ws"
        fi
    done;

    l_msg="%{F$BLACK}${PL_L}%{F-}%{B$BLACK}"
    r_msg="%{B-}%{F$BLACK}${PL_R}%{F-}"

    msg="$l_msg %{F$WHITE}${ICON_WORKSPACES}%{F-}$msg  $r_msg"

    echo "$ANCHOR_WORKSPACES$msg"

    ) &
done
#+end_src

** Compton X11 Compositor
:PROPERTIES:
:header-args:conf: :tangle ~/.config/compton.conf :mkdirp yes
:END:
[[http://9m.no/êª¯éµ][Thank you code_nomad!]] Copied a lot of this person's config...
*** Backend

Backend to use: "xrender" or "glx".
GLX backend is typically much faster but depends on a sane driver.

#+begin_src conf
# Provide the backend to use
backend = "xrender";
#+end_src

*** GLX backend

#+begin_src conf
# ??? Don't remember what this does...
glx-no-stencil = true;

# GLX backend: Copy unmodified regions from front buffer instead of redrawing them all.
# My tests with nvidia-drivers show a 10% decrease in performance when the whole screen is modified,
# but a 20% increase when only 1/4 is.
# My tests on nouveau show terrible slowdown.
# Useful with --glx-swap-method, as well.
glx-copy-from-front = false;

# GLX backend: Avoid rebinding pixmap on window damage.
# Probably could improve performance on rapid window content changes, but is known to break things on some drivers (LLVMpipe).
# Recommended if it works.
# glx-no-rebind-pixmap = true;

# GLX backend: GLX buffer swap method we assume.
# Could be undefined (0), copy (1), exchange (2), 3-6, or buffer-age (-1).
# undefined is the slowest and the safest, and the default value.
# copy is fastest, but may fail on some drivers,
# 2-6 are gradually slower but safer (6 is still faster than 0).
# Usually, double buffer means 2, triple buffer means 3.
# buffer-age means auto-detect using GLX_EXT_buffer_age, supported by some drivers.
# Useless with --glx-use-copysubbuffermesa.
# Partially breaks --resize-damage.
# Defaults to undefined.
glx-swap-method = "undefined";
#+end_src

*** Shadows

#+begin_src conf
# Enabled client-side shadows on windows.
shadow = true;
# Don't draw shadows on DND windows.
no-dnd-shadow = true;
# Avoid drawing shadows on dock/panel windows.
no-dock-shadow = true;
# Zero the part of the shadow's mask behind the window. Fix some weirdness with ARGB windows.
clear-shadow = true;
# The blur radius for shadows. (default 12)
shadow-radius = 5;
# The left offset for shadows. (default -15)
shadow-offset-x = -5;
# The top offset for shadows. (default -15)
shadow-offset-y = -5;
# The translucency for shadows. (default .75)
shadow-opacity = 0.5;

# Set if you want different colour shadows
# shadow-red = 0.0;
# shadow-green = 0.0;
# shadow-blue = 0.0;

# The shadow exclude options are helpful if you have shadows enabled. Due to the way compton draws its shadows, certain applications will have visual glitches
# (most applications are fine, only apps that do weird things with xshapes or argb are affected).
# This list includes all the affected apps I found in my testing. The "! name~=''" part excludes shadows on any "Unknown" windows, this prevents a visual glitch with the XFWM alt tab switcher.
shadow-exclude = [
    "! name~=''",
    "name = 'Notification'",
    "name = 'Plank'",
    "name = 'Docky'",
    "name = 'Kupfer'",
    "name = 'xfce4-notifyd'",
    "name *= 'VLC'",
    "name *= 'compton'",
    "name *= 'Chromium'",
    "name *= 'Chrome'",
    "class_g = 'Conky'",
    "class_g = 'Kupfer'",
    "class_g = 'Synapse'",
    "class_g ?= 'Notify-osd'",
    "class_g ?= 'Cairo-dock'",
    "class_g ?= 'Xfce4-notifyd'",
    "class_g ?= 'Xfce4-power-manager'",
    "_GTK_FRAME_EXTENTS@:c"
];
# Avoid drawing shadow on all shaped windows (see also: --detect-rounded-corners)
shadow-ignore-shaped = false;
#+end_src

*** Opacity

#+begin_src conf
# Define opacity
menu-opacity = 1;
inactive-opacity = 1;
active-opacity = 1;
frame-opacity = 1;
inactive-opacity-override = false;
alpha-step = 0.06;

# Dim inactive windows. (0.0 - 1.0)
# inactive-dim = 0.2;
# Do not let dimness adjust based on window opacity.
# inactive-dim-fixed = true;
# Blur background of transparent windows. Bad performance with X Render backend. GLX backend is preferred.
# blur-background = true;
# Blur background of opaque windows with transparent frames as well.
# blur-background-frame = true;
# Do not let blur radius adjust based on window opacity.
blur-background-fixed = false;
blur-background-exclude = [
    "window_type = 'dock'",
    "window_type = 'desktop'"
];
#+end_src

*** Fading

#+begin_src conf
# Fade windows during opacity changes.
fading = true;
# The time between steps in a fade in milliseconds. (default 10).
fade-delta = 4;
# Opacity change between steps while fading in. (default 0.028).
fade-in-step = 0.03;
# Opacity change between steps while fading out. (default 0.03).
fade-out-step = 0.03;
# Fade windows in/out when opening/closing
# no-fading-openclose = true;

# Specify a list of conditions of windows that should not be faded.
fade-exclude = [ ];
#+end_src

*** Other

#+begin_src conf
# Try to detect WM windows and mark them as active.
mark-wmwin-focused = true;
# Mark all non-WM but override-redirect windows active (e.g. menus).
mark-ovredir-focused = true;
# Use EWMH _NET_WM_ACTIVE_WINDOW to determine which window is focused instead of using FocusIn/Out events.
# Usually more reliable but depends on a EWMH-compliant WM.
use-ewmh-active-win = true;
# Detect rounded corners and treat them as rectangular when --shadow-ignore-shaped is on.
detect-rounded-corners = true;

# Detect _NET_WM_OPACITY on client windows, useful for window managers not passing _NET_WM_OPACITY of client windows to frame windows.
# This prevents opacity being ignored for some apps.
# For example without this enabled my xfce4-notifyd is 100% opacity no matter what.
detect-client-opacity = true;

# Specify refresh rate of the screen.
# If not specified or 0, compton will try detecting this with X RandR extension.
refresh-rate = 0;

# Set VSync method. VSync methods currently available:
# none: No VSync
# drm: VSync with DRM_IOCTL_WAIT_VBLANK. May only work on some drivers.
# opengl: Try to VSync with SGI_video_sync OpenGL extension. Only work on some drivers.
# opengl-oml: Try to VSync with OML_sync_control OpenGL extension. Only work on some drivers.
# opengl-swc: Try to VSync with SGI_swap_control OpenGL extension. Only work on some drivers. Works only with GLX backend. Known to be most effective on many drivers. Does not actually control paint timing, only buffer swap is affected, so it doesnât have the effect of --sw-opti unlike other methods. Experimental.
# opengl-mswc: Try to VSync with MESA_swap_control OpenGL extension. Basically the same as opengl-swc above, except the extension we use.
# (Note some VSync methods may not be enabled at compile time.)
vsync = "opengl-swc";

# Enable DBE painting mode, intended to use with VSync to (hopefully) eliminate tearing.
# Reported to have no effect, though.
dbe = false;
# Painting on X Composite overlay window. Recommended.
paint-on-overlay = true;

# Limit compton to repaint at most once every 1 / refresh_rate second to boost performance.
# This should not be used with --vsync drm/opengl/opengl-oml as they essentially does --sw-opti's job already,
# unless you wish to specify a lower refresh rate than the actual value.
sw-opti = true;

# Unredirect all windows if a full-screen opaque window is detected, to maximize performance for full-screen windows, like games.
# Known to cause flickering when redirecting/unredirecting windows.
# paint-on-overlay may make the flickering less obvious.
unredir-if-possible = true;

# Specify a list of conditions of windows that should always be considered focused.
focus-exclude = [ ];

# Use WM_TRANSIENT_FOR to group windows, and consider windows in the same group focused at the same time.
detect-transient = true;
# Use WM_CLIENT_LEADER to group windows, and consider windows in the same group focused at the same time.
# WM_TRANSIENT_FOR has higher priority if --detect-transient is enabled, too.
detect-client-leader = true;
#+end_src

*** Window Type Settings

#+begin_src conf
wintypes:
{
    tooltip =
    {
        # fade: Fade the particular type of windows.
        fade = true;
        # shadow: Give those windows shadow
        shadow = false;
        # opacity: Default opacity for the type of windows.
        opacity = 0.85;
        # focus: Whether to always consider windows of this type focused.
        focus = true;
    };
};
#+end_src

** Zathura PDF Reader
:PROPERTIES:
:header-args:conf: :tangle ~/.config/zathura/zathurarc :mkdirp yes
:END:
*** Re-Color Pages

Uncomment the first line if you want to have the the pages recolored by default.

#+begin_src conf
#set recolor true
set recolor-darkcolor "#ebdbb2"
set recolor-lightcolor "#000000"
#+end_src

*** Highlighting

#+begin_src conf
set highlight-color "#b16286"
set highlight-active-color "#458588"
set highlight-transparency 0.75
#+end_src
